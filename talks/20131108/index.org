#+Title: Embedded Software Verification
#+Author: [[http://www.cs.cmu.edu/~sicung][Sicun Gao]] / [[http://www.cs.cmu.edu/~soonhok][Soonho Kong]] / [[http://www.cs.cmu.edu/~emc][Edmund Clarke]] / S. Ramesh
#+Date: 2013/11/08
#+REVEAL_Title_Img: ./img/logo.svg
#+REVEAL_Title_Img_Width:  600px
#+REVEAL_Title_Top_Margin: 200px
#+REVEAL_Venue: GM VIT-CRL Review
#+REVEAL_Webpage: http://dreal.cs.cmu.edu
#+Email:
#+Creator:
#+REVEAL_TRANS: none
#+REVEAL_THEME: sean
#+REVEAL_HLEVEL: 3
#+REVEAL_EXTRA_CSS:../reveal.js/lib/css/googlecode.css
#+REVEAL_HEAD_PREAMBLE: <script type="text/javascript">MathJax.Hub.Config({"HTML-CSS": {scale: 100 }})</script>
#+OPTIONS: toc:nil reveal_mathjax:t num:nil reveal_center:nil reveal_control:nil
#+OPTIONS: reveal_rolling_links:nil
#+OPTIONS: reveal_width:950 reveal_height:700
#+REVEAL_MARGIN: 0.1
#+REVEAL_MIN_SCALE: 0.5
#+REVEAL_MAX_SCALE: 2.5

* Activities
#+ATTR_REVEAL: :frag fade-in
 - "Satisfiability Modulo ODEs," Sicun Gao, Soonho Kong, and Edmund
   Clarke. In FMCAD (Formal Methods in Computer-Aided Design) 2013
 - "Extracting Proofs from Branch-and-Prune," Sicun Gao, Soonho Kong,
   and Edmund Clarke. CMU SCS Technical Report CMU-CS-13-104
 - [In Progress] Case study of trajectory following algorithms in
   autonomous driving.
 - Sicun Gao's Ph.D. thesis "Computable Analysis, Decision Procedures,
   and Hybrid Automata: A New Framework for the Formal Verification of
   Cyber-Physical Systems" won SCS Distinguished Dissertation Award
   Honorable Mention.

* Media Attentions - Toyota
#+attr_html: :height 550px
  [[./img/Toyota_EDN.png]]

* Media Attentions - Nissan
#+attr_html: :height 550px
  [[./img/Nissan_CNN.png]]

* Sudden Unintended Acceleration

  [[./img/SUA_excerpt.png]]

* Common Myths

 - If every engineer is good and careful and makes almost no human
   errors, then verification is redundant.


 - Even if there are errors, they occur with very low possibility
   after sufficient simulation and testing.

* Bugs in C Standard Library Implementation

#+BEGIN_CODE
#include &lt;math.h&gt;
#include &lt;fenv.h&gt;
#include &lt;stdio.h&gt;

int main() {
    double x = 0.6932;
    fesetround(FE_UPWARD);
    printf("exp(%f) = %f\n", x, exp(x));
    return 0;
}
#+END_CODE

$$
\exp(0.6932) \simeq 2.00010564167
$$

* Bugs in C Standard Library Implementation

#+BEGIN_CODE
#include &lt;math.h&gt;
#include &lt;fenv.h&gt;
#include &lt;stdio.h&gt;

int main() {
    double x = 0.6932;
    fesetround(FE_UPWARD);
    printf("exp(%f) = %f\n", x, exp(x));
    return 0;
}
#+END_CODE

$$
\exp(0.6932) \simeq 2.00010564167
$$

$$\text{Result: (on Ubuntu 12.04 LTS)}$$

#+BEGIN_CODE
$ gcc exp_bug.c -lm
$ ./a.out
exp(0.693200) = 0.000000
#+END_CODE

* Bugs in C Standard Library Implementation

#+BEGIN_CODE
#include &lt;math.h&gt;
#include &lt;fenv.h&gt;
#include &lt;stdio.h&gt;

int main() {
    double x = 0.8516;
    fesetround(FE_UPWARD);
    printf("sin(%f) = %f\n", x, sin(x));
    return 0;
}
#+END_CODE

$$
\sin(0.8516) \simeq 0.75233541608
$$

* Bugs in C Standard Library Implementation

#+BEGIN_CODE
#include &lt;math.h&gt;
#include &lt;fenv.h&gt;
#include &lt;stdio.h&gt;

int main() {
    double x = 0.8516;
    fesetround(FE_UPWARD);
    printf("sin(%f) = %f\n", x, sin(x));
    return 0;
}
#+END_CODE

$$
\sin(0.8516) \simeq 0.75233541608
$$

$$\text{Result: (on Ubuntu 12.04 LTS)}$$

#+BEGIN_CODE
$ gcc sin_bug.c -lm
$ ./a.out
sin(0.851600) = 1489379514151358920516114347498016545730127812624384.000000
#+END_CODE

* Bugs in C Standard Library Implementation

#+BEGIN_CODE
sin(0.851600) =  1489379514166203240312541868623153924051691095719936,   0.752335
sin(0.851700) =  1470223886137434186582383647305823032194319505162240,   0.752401
sin(0.851800) =  1451068243406426350740654485391317642471148315738112,   0.752467
sin(0.851900) =  1431912586164736108487914394239678294146238264639488,   0.752533
sin(0.852000) =  1412756914603920167831722331439913752435415159144448,   0.752599
sin(0.852100) =  1393601228915534738319138835237580443626857201401856,   0.752665
sin(0.852200) =  1374445529291137192571720755679623584839920338862080,   0.752731
sin(0.852300) =  1355289815922284404750526523469536054266312913846272,   0.752796
sin(0.852400) =  1336134089000533415170114042425294843073625803718656,   0.752862
sin(0.852500) =  1316978348717441596452040162593845168381214955929600,   0.752928
sin(0.852600) =  1297822595264566155064362260907648134332553782886400,   0.752994
sin(0.852700) =  1278666828833464962089135606757101296974645837168640,   0.753060
sin(0.852800) =  1259511049615695390147917050189149873426847066226688,   0.753125
sin(0.852900) =  1240355257802815476476261333708675532712043557683200,   0.753191
sin(0.853000) =  1221199453586382759849224780477107604925473794031616,   0.753257
sin(0.853100) =  1202043637157955775962860552342780098017671468023808,   0.753323
sin(0.853200) =  1182887808709092395899223918696090568035640132239360,   0.753389
sin(0.853300) =  1163731968431350656893869622041920684002265874300928,   0.753454
sin(0.853400) =  1144576116516289426949849770457572679819847457046528,   0.753520
sin(0.853500) =  1125420253155467241763217525791380563438918573228032,   0.753586
sin(0.853600) =  1106264378540442138569527630548226003882365310468096,   0.753651
sin(0.853700) =  1087108492862773649985830085263347686956016571777024,   0.753717
sin(0.853800) =  1067952596314019979401179105556111394658640979820544,   0.753783
sin(0.853900) =  1048796689085740493279125218847271699820184902565888,   0.753849
sin(0.854000) =  1029640771369493893469221060099646723367064567808000,   0.753914
sin(0.854100) =  1010484843356839878742016102962959264080991413600256,   0.753980
sin(0.854200) =   991328905239337317100562455514511555864264202780672,   0.754046
sin(0.854300) =   972172957208545575008410645175058171546829303316480,   0.754111
sin(0.854400) =   953016999456024351236110145594321909910398153261056,   0.754177
sin(0.854500) =   933861032173333178400710957307541456760799655624704,   0.754243
sin(0.854600) =   914705055552031755272762553964439610879745248460800,   0.754308
sin(0.854700) =   895549069783679780622814409214739171048946369822720,   0.754374
sin(0.854800) =   876393075059837119374915469822647049025996992806912,   0.754440
sin(0.854900) =   857237071572063636453114682552370156568491090509824,   0.754505
sin(0.855000) =   838081059511919529088459940397083631385787706114048,   0.754571
sin(0.855100) =   818925039070964662205000190120994385235480812716032,   0.754637
sin(0.855200) =   799769010440759565340782270946245781778694523584512,   0.754702
sin(0.855300) =   780612973812864269573354602751528845748905346859008,   0.754768
sin(0.855400) =   761456929378839304440764024758986940807237395808256,   0.754833
sin(2.422400) = -191556211607501065506045167489854885550193095389216768, 0.658777
sin(2.422500) = -191556359517308652735718296043464882429588650430824448, 0.658702
sin(2.422600) = -191556505511552631833326838907247251894767584951664640, 0.658627
sin(2.422700) = -191556649590231556598811382092732274603648313936838656, 0.658552
sin(2.422800) = -191556791753343980832112511611450231214149252371447808, 0.658477
sin(2.422900) = -191556932000888500868466678592239335306014744211619840, 0.658401
sin(2.423000) = -191557070332863691775462401605283833998076168927969280, 0.658326
sin(2.423100) = -191557206749268192423631996896729873791903799447650304, 0.658251
sin(2.423200) = -191557341250100620415859848154069634728154944212303872, 0.658175
sin(2.423300) = -191557473835359635890326204182103229769312840634597376, 0.658100
sin(2.423400) = -191557604505043920252859246344284738338773690612711424, 0.658025
sin(2.423500) = -191557733259152154909287156004068239859933696044826624, 0.657950
sin(2.423600) = -191557860097683063800733979642215746678014987800150016, 0.657874
sin(2.423700) = -191557985020635370868323763739489271138239696747888640, 0.657799
sin(2.423800) = -191558108028007821320828487335304792046742918242762752, 0.657724
sin(2.423900) = -191558229119799202902315994586386221131485676610519040, 0.657648
sin(2.424000) = -191558348296008303356854129649457470120428996176904192, 0.657573
sin(2.424100) = -191558465556633910428510736681242450741533901267664896, 0.657498
sin(2.424200) = -191558580901674854396649524955773007644587345179574272, 0.657422
sin(2.424300) = -191558694331130008075930068864388918401202210180431872, 0.657347
sin(2.424400) = -191558805844998223013364010239775994122078414052524032, 0.657271
sin(2.424500) = -191558915443278372023610923473274012378828839063650304, 0.657196
sin(2.424600) = -191559023125969349188978315514876717203979331967123456, 0.657121
sin(2.424700) = -191559128893070133662365423549193718473707597458309120, 0.657045
sin(2.424800) = -191559232744579598258431821967564793759626517805006848, 0.656970
sin(2.424900) = -191559334680496764665372613071907485859739726673608704, 0.656895
sin(2.425000) = -191559434700820569500791168929523471728398999788453888, 0.656819
sin(2.425100) = -191559532805550034452882591842330294163607970815934464, 0.656744
sin(2.425200) = -191559628994684159942194051553591529502457308936929280, 0.656668
sin(2.425300) = -191559723268222010192216515482532653464776576788856832, 0.656593
sin(2.425400) = -191559815626162628158793018489725175309482372523622400, 0.656518
sin(2.425500) = -191559906068505099333062460553048537217317223264157696, 0.656442
sin(2.425600) = -191559994595248487938515809091728214908110691647881216, 0.656367
sin(2.425700) = -191560081206391964536883694318259516406257162739777536, 0.656291
sin(2.425800) = -191560165901934614619305016210521883892499163662778368, 0.656216
sin(2.425900) = -191560248681875587479862472422356658930318114996355072, 0.656140
sin(2.426000) = -191560329546214096215582558283567082465934330776518656, 0.656065
sin(2.426100) = -191560408494949311388195904006648462523742196068253696, 0.655989
sin(2.426200) = -191560485528080446094729004921404040049962024907571200, 0.655914
#+END_CODE

* Bugs in C Standard Library Implementation

#+BEGIN_CODE
cos(0.851600) = -191556206137995771412122791854704340617188789159198720, 0.658780
cos(0.851700) = -191556354118165925626606813067880548697503079661043712, 0.658705
cos(0.851800) = -191556500182772514244322113708537062285426678613147648, 0.658630
cos(0.851900) = -191556644331814112332857212346858128499790965486125056, 0.658555
cos(0.852000) = -191556786565289273692152694994374027998514355265077248, 0.658479
cos(0.852100) = -191556926883196573389797080221269007900428227420618752, 0.658404
cos(0.852200) = -191557065285534586493378886597727315324363961423364096, 0.658329
cos(0.852300) = -191557201772301973141078362928549063232804794685980672, 0.658253
cos(0.852400) = -191557336343497329668131960342572465205495071164596224, 0.658178
cos(0.852500) = -191557468999119316212719927644597634204918028271878144, 0.658103
cos(0.852600) = -191557599739166635448318378756732616115382832391520256, 0.658028
cos(0.852700) = -191557728563637947513107562483777523899372720936189952, 0.657952
cos(0.852800) = -191557855472531976348211525306494369902109824775094272, 0.657877
cos(0.852900) = -191557980465847445894754313705645166468816274777440256, 0.657802
cos(0.853000) = -191558103543583122629155839279299858866540130783461376, 0.657726
cos(0.853100) = -191558224705737751760188081066874425901416488147877888, 0.657651
cos(0.853200) = -191558343952310142299566815783746745762319335681949696, 0.657576
cos(0.853300) = -191558461283299103259007820145294696638122662196936704, 0.657500
cos(0.853400) = -191558576698703443650226870866896156717700456504098816, 0.657425
cos(0.853500) = -191558690198522015020235609781236937111752636385722368, 0.657350
cos(0.853600) = -191558801782753690183693611279656815391892084109606912, 0.657274
cos(0.853700) = -191558911451397363222908382312149535590644646429065216, 0.657199
cos(0.853800) = -191559019204451906952539497270054875279623205611896832, 0.657124
cos(0.853900) = -191559125041916257990190328220674511413179537382440960, 0.657048
cos(0.854000) = -191559228963789374221112179789964087406578381950550016, 0.656973
cos(0.854100) = -191559330970070192262908424045225280214171515040563200, 0.656897
cos(0.854200) = -191559431060757712536126230729721666173049605833359360, 0.656822
cos(0.854300) = -191559529235850914193664837028062855159390359024304128, 0.656747
cos(0.854400) = -191559625495348840191367277800820356432110372765302784, 0.656671
cos(0.854500) = -191559719839250490949780722791257746328300316237234176, 0.656596
cos(0.854600) = -191559812267554951960044071977254467028702716563030016, 0.656520
cos(0.854700) = -191559902780261287445648292778035994253147136380108800, 0.656445
cos(0.854800) = -191559991377368604165380217730135736643289067296915456, 0.656369
cos(0.854900) = -191560078058876008878026679370087102840784000921894912, 0.656294
cos(0.855000) = -191560162824782629610022442793077467948200393349005312, 0.656219
cos(0.855100) = -191560245675087636923098138211602139989932629643231232, 0.656143
cos(0.855200) = -191560326609790180111336463279502460529462130384044032, 0.656068
cos(0.855300) = -191560405628889451004115980767927704052096245121941504, 0.655992
cos(0.855400) = -191560482732384683966111118565335077964968252378447872, 0.655917
cos(2.422400) = -1488675888775640720961810138597320654915534736850944,  -0.752338
cos(2.422500) = -1469520260203396862735052288905174689356640061227008,  -0.752404
cos(2.422600) = -1450364616935950490792410950789070528605539790749696,  -0.752470
cos(2.422700) = -1431208959164857648527447189380080485974529592524800,  -0.752535
cos(2.422800) = -1412053287081675376254718908496181552631200343916544,  -0.752601
cos(2.422900) = -1392897600877960381981785065726382493791377852203008,  -0.752667
cos(2.423000) = -1373741900745269207562705145545207961695005389619200,  -0.752733
cos(2.423100) = -1354586186875159059465536524885119060485556368572416,  -0.752799
cos(2.423200) = -1335430459459187144158336580678576894306504201469952,  -0.752865
cos(2.423300) = -1316274718688910501955663216743558454325439765676032,  -0.752930
cos(2.423400) = -1297118964755886837786072229355977183613484078727168,  -0.752996
cos(2.423500) = -1277963197851673358117620995448294186314110553030656,  -0.753062
cos(2.423600) = -1258807418167827934032364784410907018474322741166080,  -0.753128
cos(2.423700) = -1239651625895908602765858338748697349117006730756096,  -0.753194
cos(2.423800) = -1220495821227472736939658508508610395361518469251072,  -0.753259
cos(2.423900) = -1201340004354078872249818455538980165158391649402880,  -0.753325
cos(2.424000) = -1182184175467284879778393449230204214554629823791104,  -0.753391
cos(2.424100) = -1163028334758649129067937178316132438524884150124544,  -0.753457
cos(2.424200) = -1143872482419730155814502804645098845019688321155072,  -0.753522
cos(2.424300) = -1124716618642086163407144543836469216037810959548416,  -0.753588
cos(2.424400) = -1105560743617276186002413977082029898457433363185664,  -0.753654
cos(2.424500) = -1086404857536858593142864793115630787253206689775616,  -0.753720
cos(2.424600) = -1067248960592392585138548046243542342279194772242432,  -0.753785
cos(2.424700) = -1048093052975436863839016371428582684461813838381056,  -0.753851
cos(2.424800) = -1028937134877550629554320822977022273655127721115648,  -0.753917
cos(2.424900) = -1009781206490293248748011928309615682689082788413440,  -0.753982
cos(2.425000) = -990625268005223589423141795503665145465977803112448,   -0.754048
cos(2.425100) = -971469319613901350350259898208893460767524203266048,   -0.754114
cos(2.425200) = -952313361507885897992916763846055201423668356841472,   -0.754179
cos(2.425300) = -933157393878736931121661866064873166216121701892096,   -0.754245
cos(2.425400) = -914001416918013816200045732286101927974830606385152,   -0.754311
cos(2.425500) = -894845430817276750459116255502916624409154113503232,   -0.754376
cos(2.425600) = -875689435768085432669422909365040054300803661299712,   -0.754442
cos(2.425700) = -856533431961999561601515167522195016431490687827968,   -0.754508
cos(2.425800) = -837377419590579500639940396082040761486456771313664,   -0.754573
cos(2.425900) = -818221398845385280862247014923268314199178419896320,   -0.754639
cos(2.426000) = -799065369917976933345983443924568699303132141715456,   -0.754705
cos(2.426100) = -779909332999914987629196522308085280459442050039808,   -0.754770
cos(2.426200) = -760753288282759807096433616181477308353349723095040,   -0.754836
#+END_CODE
* Bugs in C Standard Library Implementation

#+BEGIN_CODE
tan(2.292000) =  -0.000000,  -1.137398
tan(2.292100) =  -0.000000,  -1.137169
tan(2.292200) =  -0.000000,  -1.136939
tan(2.292300) =  -0.000000,  -1.136710
tan(2.292400) =  -0.000000,  -1.136481
tan(2.292500) =  -0.000000,  -1.136252
tan(2.292600) =  -0.000000,  -1.136023
tan(2.292700) =  -0.000000,  -1.135794
tan(2.292800) =  -0.000000,  -1.135565
tan(2.292900) =  -0.000000,  -1.135336
tan(2.293000) =  -0.000000,  -1.135107
tan(2.293100) =  -0.000000,  -1.134878
tan(2.293200) =  -0.000000,  -1.134649
tan(2.293300) =  -0.000000,  -1.134421
tan(2.293400) =  -0.000000,  -1.134192
tan(2.293500) =  -0.000000,  -1.133963
tan(2.293600) =  -0.000000,  -1.133735
tan(2.293700) =  -0.000000,  -1.133506
tan(2.293800) =  -0.000000,  -1.133278
tan(2.293900) =  -0.000000,  -1.133049
tan(2.294000) =  -0.000000,  -1.132821
tan(2.294100) =  -0.000000,  -1.132593
tan(2.294200) =  -0.000000,  -1.132364
tan(2.294300) =  -0.000000,  -1.132136
tan(2.294400) =  -0.000000,  -1.131908
tan(2.294500) =  -0.000000,  -1.131680
tan(2.294600) =  -0.000000,  -1.131452
tan(2.294700) =  -0.000000,  -1.131224
tan(2.294800) =  -0.000000,  -1.130996
tan(2.294900) =  -0.000000,  -1.130768
tan(2.295000) =  -0.000000,  -1.130540
tan(2.295100) =  -0.000000,  -1.130313
tan(2.295200) =  -0.000000,  -1.130085
tan(2.295300) =  -0.000000,  -1.129857
tan(2.295400) =  -0.000000,  -1.129629
tan(2.295500) =  -0.000000,  -1.129402
tan(2.295600) =  -0.000000,  -1.129174
tan(2.295700) =  -0.000000,  -1.128947
tan(2.295800) =  -0.000000,  -1.128719
tan(2.295900) =  -0.000000,  -1.128492
tan(2.296000) =  -0.000000,  -1.128265
tan(2.296100) =  -0.000000,  -1.128037
tan(2.296200) =  -0.000000,  -1.127810
tan(2.296300) =  -0.000000,  -1.127583
tan(2.296400) =  -0.000000,  -1.127356
tan(2.296500) =  -0.000000,  -1.127129
tan(2.296600) =  -0.000000,  -1.126902
tan(2.296700) =  -0.000000,  -1.126675
tan(2.296800) =  -0.000000,  -1.126448
tan(2.296900) =  -0.000000,  -1.126221
tan(2.297000) =  -0.000000,  -1.125994
tan(2.297100) =  -0.000000,  -1.125768
tan(2.297200) =  -0.000000,  -1.125541
tan(2.297300) =  -0.000000,  -1.125314
tan(2.297400) =  -0.000000,  -1.125088
tan(2.297500) =  -0.000000,  -1.124861
tan(2.297600) =  -0.000000,  -1.124635
tan(2.297700) =  -0.000000,  -1.124408
tan(2.297800) =  -0.000000,  -1.124182
tan(2.297900) =  -0.000000,  -1.123955
tan(2.298000) =  -0.000000,  -1.123729
tan(2.298100) =  -0.000000,  -1.123503
tan(2.298200) =  -0.000000,  -1.123277
tan(2.298300) =  -0.000000,  -1.123050
tan(2.298400) =  -0.000000,  -1.122824
tan(2.298500) =  -0.000000,  -1.122598
tan(2.298600) =  -0.000000,  -1.122372
tan(2.298700) =  -0.000000,  -1.122146
tan(2.298800) =  -0.000000,  -1.121920
tan(2.298900) =  -0.000000,  -1.121695
tan(2.299000) =  -0.000000,  -1.121469
tan(2.299100) =  -0.000000,  -1.121243
tan(2.299200) =  -0.000000,  -1.121017
tan(2.299300) =  -0.000000,  -1.120792
tan(2.299400) =  -0.000000,  -1.120566
tan(2.299500) =  -0.000000,  -1.120341
tan(2.299600) =  -0.000000,  -1.120115
tan(2.299700) =  -0.000000,  -1.119890
tan(2.299800) =  -0.000000,  -1.119664
tan(2.299900) =  -0.000000,  -1.119439
tan(2.300000) =  -0.000000,  -1.119214
tan(2.300100) =  -0.000000,  -1.118988
tan(2.300200) =  -0.000000,  -1.118763
tan(2.300300) =  -0.000000,  -1.118538
tan(2.300400) =  -0.000000,  -1.118313
tan(2.300500) =  -0.000000,  -1.118088
tan(2.300600) =  -0.000000,  -1.117863
tan(2.300700) =  -0.000000,  -1.117638
tan(2.300800) =  -0.000000,  -1.117413
tan(2.300900) =  -0.000000,  -1.117188
tan(2.301000) =  -0.000000,  -1.116964
tan(2.301100) =  -0.000000,  -1.116739
tan(2.301200) =  -0.000000,  -1.116514
tan(2.301300) =  -0.000000,  -1.116289
tan(2.301400) =  -0.000000,  -1.116065
tan(2.301500) =  -0.000000,  -1.115840
tan(2.301600) =  -0.000000,  -1.115616
tan(2.301700) =  -0.000000,  -1.115391
tan(2.301800) =  -0.000000,  -1.115167
tan(2.301900) =  -0.000000,  -1.114943
tan(2.302000) =  -0.000000,  -1.114718
tan(2.302100) =  -0.000000,  -1.114494
tan(2.302200) =  -0.000000,  -1.114270
tan(2.302300) =  -0.000000,  -1.114046
tan(2.302400) =  -0.000000,  -1.113822
tan(2.302500) =  -0.000000,  -1.113598
tan(2.302600) =  -0.000000,  -1.113374
tan(2.302700) =  -0.000000,  -1.113150
tan(2.302800) =  -0.000000,  -1.112926
tan(2.302900) =  -0.000000,  -1.112702
tan(2.303000) =  -0.000000,  -1.112478
tan(2.303100) =  -0.000000,  -1.112255
tan(2.303200) =  -0.000000,  -1.112031
tan(2.303300) =  -0.000000,  -1.111807
tan(2.303400) =  -0.000000,  -1.111584
tan(2.303500) =  -0.000000,  -1.111360
tan(2.303600) =  -0.000000,  -1.111137
tan(2.303700) =  -0.000000,  -1.110913
tan(2.303800) =  -0.000000,  -1.110690
tan(2.303900) =  -0.000000,  -1.110466
tan(2.304000) =  -0.000000,  -1.110243
tan(2.304100) =  -0.000000,  -1.110020
tan(2.304200) =  -0.000000,  -1.109797
tan(2.304300) =  -0.000000,  -1.109574
tan(2.304400) =  -0.000000,  -1.109351
tan(2.304500) =  -0.000000,  -1.109127
tan(2.304600) =  -0.000000,  -1.108905
tan(2.304700) =  -0.000000,  -1.108682
tan(2.304800) =  -0.000000,  -1.108459
tan(2.304900) =  -0.000000,  -1.108236
tan(2.305000) =  -0.000000,  -1.108013
tan(2.305100) =  -0.000000,  -1.107790
tan(2.305200) =  -0.000000,  -1.107568
tan(2.305300) =  -0.000000,  -1.107345
tan(2.305400) =  -0.000000,  -1.107122
tan(2.305500) =  -0.000000,  -1.106900
tan(2.305600) =  -0.000000,  -1.106677
tan(2.305700) =  -0.000000,  -1.106455
tan(2.305800) =  -0.000000,  -1.106232
tan(2.305900) =  -0.000000,  -1.106010
tan(2.306000) =  -0.000000,  -1.105788
tan(2.306100) =  -0.000000,  -1.105566
tan(2.306200) =  -0.000000,  -1.105343
tan(2.306300) =  -0.000000,  -1.105121
tan(2.306400) =  -0.000000,  -1.104899
tan(2.306500) =  -0.000000,  -1.104677
tan(2.306600) =  -0.000000,  -1.104455
tan(2.306700) =  -0.000000,  -1.104233
tan(2.306800) =  -0.000000,  -1.104011
tan(2.306900) =  -0.000000,  -1.103789
tan(2.307000) =  -0.000000,  -1.103567
tan(2.307100) =  -0.000000,  -1.103346
tan(2.307200) =  -0.000000,  -1.103124
tan(2.307300) =  -0.000000,  -1.102902
tan(2.307400) =  -0.000000,  -1.102681
tan(2.307500) =  -0.000000,  -1.102459
tan(2.307600) =  -0.000000,  -1.102238
tan(2.307700) =  -0.000000,  -1.102016
tan(2.307800) =  -0.000000,  -1.101795
tan(2.307900) =  -0.000000,  -1.101573
tan(2.308000) =  -0.000000,  -1.101352
tan(2.308100) =  -0.000000,  -1.101131
tan(2.308200) =  -0.000000,  -1.100910
tan(2.308300) =  -0.000000,  -1.100688
tan(2.308400) =  -0.000000,  -1.100467
tan(2.308500) =  -0.000000,  -1.100246
tan(2.308600) =  -0.000000,  -1.100025
tan(2.308700) =  -0.000000,  -1.099804
tan(2.308800) =  -0.000000,  -1.099583
tan(2.308900) =  -0.000000,  -1.099362
tan(2.309000) =  -0.000000,  -1.099142
tan(2.309100) =  -0.000000,  -1.098921
tan(2.309200) =  -0.000000,  -1.098700
tan(2.309300) =  -0.000000,  -1.098479
tan(2.309400) =  -0.000000,  -1.098259
tan(2.309500) =  -0.000000,  -1.098038
tan(2.309600) =  -0.000000,  -1.097818
tan(2.309700) =  -0.000000,  -1.097597
tan(2.309800) =  -0.000000,  -1.097377
tan(2.309900) =  -0.000000,  -1.097156
tan(2.310000) =  -0.000000,  -1.096936
tan(2.310100) =  -0.000000,  -1.096716
tan(2.310200) =  -0.000000,  -1.096495
tan(2.310300) =  -0.000000,  -1.096275
tan(2.310400) =  -0.000000,  -1.096055
tan(2.310500) =  -0.000000,  -1.095835
tan(2.310600) =  -0.000000,  -1.095615
tan(2.310700) =  -0.000000,  -1.095395
tan(2.310800) =  -0.000000,  -1.095175
tan(2.310900) =  -0.000000,  -1.094955
tan(2.311000) =  -0.000000,  -1.094735
tan(2.311100) =  -0.000000,  -1.094515
tan(2.311200) =  -0.000000,  -1.094295
tan(2.311300) =  -0.000000,  -1.094076
tan(2.311400) =  -0.000000,  -1.093856
tan(2.311500) =  -0.000000,  -1.093636
tan(2.311600) =  -0.000000,  -1.093417
tan(2.311700) =  -0.000000,  -1.093197
tan(2.311800) =  -0.000000,  -1.092978
tan(2.311900) =  -0.000000,  -1.092758
tan(2.312000) =  -0.000000,  -1.092539
tan(2.312100) =  -0.000000,  -1.092320
tan(2.312200) =  -0.000000,  -1.092100
tan(2.312300) =  -0.000000,  -1.091881
tan(2.312400) =  -0.000000,  -1.091662
tan(2.312500) =  -0.000000,  -1.091443
tan(2.312600) =  -0.000000,  -1.091224
tan(2.312700) =  -0.000000,  -1.091005
tan(2.312800) =  -0.000000,  -1.090786
tan(2.312900) =  -0.000000,  -1.090567
tan(2.313000) =  -0.000000,  -1.090348
tan(2.313100) =  -0.000000,  -1.090129
tan(2.313200) =  -0.000000,  -1.089910
tan(2.313300) =  -0.000000,  -1.089691
tan(2.313400) =  -0.000000,  -1.089473
tan(2.313500) =  -0.000000,  -1.089254
tan(2.313600) =  -0.000000,  -1.089035
tan(2.313700) =  -0.000000,  -1.088817
tan(2.313800) =  -0.000000,  -1.088598
tan(2.313900) =  -0.000000,  -1.088380
tan(2.314000) =  -0.000000,  -1.088161
tan(2.314100) =  -0.000000,  -1.087943
tan(2.314200) =  -0.000000,  -1.087725
tan(2.314300) =  -0.000000,  -1.087506
tan(2.314400) =  -0.000000,  -1.087288
tan(2.314500) =  -0.000000,  -1.087070
tan(2.314600) =  -0.000000,  -1.086852
tan(2.314700) =  -0.000000,  -1.086634
tan(2.314800) =  -0.000000,  -1.086415
tan(2.314900) =  -0.000000,  -1.086197
tan(2.315000) =  -0.000000,  -1.085980
tan(2.315100) =  -0.000000,  -1.085762
tan(2.315200) =  -0.000000,  -1.085544
tan(2.315300) =  -0.000000,  -1.085326
tan(2.315400) =  -0.000000,  -1.085108
tan(2.315500) =  -0.000000,  -1.084890
tan(2.315600) =  -0.000000,  -1.084673
tan(2.315700) =  -0.000000,  -1.084455
tan(2.315800) =  -0.000000,  -1.084238
tan(2.315900) =  -0.000000,  -1.084020
tan(2.316000) =  -0.000000,  -1.083803
tan(2.316100) =  -0.000000,  -1.083585
tan(2.316200) =  -0.000000,  -1.083368
tan(2.316300) =  -0.000000,  -1.083150
tan(2.316400) =  -0.000000,  -1.082933
tan(2.316500) =  -0.000000,  -1.082716
tan(2.316600) =  -0.000000,  -1.082499
tan(2.316700) =  -0.000000,  -1.082281
tan(2.316800) =  -0.000000,  -1.082064
tan(2.316900) =  -0.000000,  -1.081847
tan(2.317000) =  -0.000000,  -1.081630
tan(2.317100) =  -0.000000,  -1.081413
tan(2.317200) =  -0.000000,  -1.081196
tan(2.317300) =  -0.000000,  -1.080979
tan(2.317400) =  -0.000000,  -1.080763
tan(2.317500) =  -0.000000,  -1.080546
tan(2.317600) =  -0.000000,  -1.080329
tan(2.317700) =  -0.000000,  -1.080112
tan(2.317800) =  -0.000000,  -1.079896
tan(2.317900) =  -0.000000,  -1.079679
tan(2.318000) =  -0.000000,  -1.079463
tan(2.318100) =  -0.000000,  -1.079246
tan(2.318200) =  -0.000000,  -1.079030
tan(2.318300) =  -0.000000,  -1.078813
tan(2.318400) =  -0.000000,  -1.078597
tan(2.318500) =  -0.000000,  -1.078381
tan(2.318600) =  -0.000000,  -1.078164
tan(2.318700) =  -0.000000,  -1.077948
tan(2.318800) =  -0.000000,  -1.077732
tan(2.318900) =  -0.000000,  -1.077516
tan(2.319000) =  -0.000000,  -1.077300
tan(2.319100) =  -0.000000,  -1.077084
tan(2.319200) =  -0.000000,  -1.076868
tan(2.319300) =  -0.000000,  -1.076652
tan(2.319400) =  -0.000000,  -1.076436
tan(2.319500) =  -0.000000,  -1.076220
tan(2.319600) =  -0.000000,  -1.076004
tan(2.319700) =  -0.000000,  -1.075788
tan(2.319800) =  -0.000000,  -1.075573
tan(2.319900) =  -0.000000,  -1.075357
tan(2.320000) =  -0.000000,  -1.075142
tan(2.320100) =  -0.000000,  -1.074926
tan(2.320200) =  -0.000000,  -1.074710
tan(2.320300) =  -0.000000,  -1.074495
tan(2.320400) =  -0.000000,  -1.074280
tan(2.320500) =  -0.000000,  -1.074064
tan(2.320600) =  -0.000000,  -1.073849
tan(2.320700) =  -0.000000,  -1.073633
tan(2.320800) =  -0.000000,  -1.073418
tan(2.320900) =  -0.000000,  -1.073203
tan(2.321000) =  -0.000000,  -1.072988
tan(2.321100) =  -0.000000,  -1.072773
tan(2.321200) =  -0.000000,  -1.072558
tan(2.321300) =  -0.000000,  -1.072343
tan(2.321400) =  -0.000000,  -1.072128
tan(2.321500) =  -0.000000,  -1.071913
tan(2.321600) =  -0.000000,  -1.071698
tan(2.321700) =  -0.000000,  -1.071483
tan(2.321800) =  -0.000000,  -1.071268
tan(2.321900) =  -0.000000,  -1.071054
tan(2.322000) =  -0.000000,  -1.070839
tan(2.322100) =  -0.000000,  -1.070624
tan(2.322200) =  -0.000000,  -1.070410
tan(2.322300) =  -0.000000,  -1.070195
tan(2.322400) =  -0.000000,  -1.069981
tan(2.322500) =  -0.000000,  -1.069766
tan(2.322600) =  -0.000000,  -1.069552
tan(2.322700) =  -0.000000,  -1.069337
tan(2.322800) =  -0.000000,  -1.069123
tan(2.322900) =  -0.000000,  -1.068909
tan(2.323000) =  -0.000000,  -1.068694
tan(2.323100) =  -0.000000,  -1.068480
tan(2.323200) =  -0.000000,  -1.068266
tan(2.323300) =  -0.000000,  -1.068052
tan(2.323400) =  -0.000000,  -1.067838
tan(2.323500) =  -0.000000,  -1.067624
tan(2.323600) =  -0.000000,  -1.067410
tan(2.323700) =  -0.000000,  -1.067196
tan(2.323800) =  -0.000000,  -1.066982
tan(2.323900) =  -0.000000,  -1.066768
tan(2.324000) =  -0.000000,  -1.066555
tan(2.324100) =  -0.000000,  -1.066341
tan(2.324200) =  -0.000000,  -1.066127
tan(2.324300) =  -0.000000,  -1.065914
tan(2.324400) =  -0.000000,  -1.065700
tan(2.324500) =  -0.000000,  -1.065486
tan(2.324600) =  -0.000000,  -1.065273
tan(2.324700) =  -0.000000,  -1.065060
tan(2.324800) =  -0.000000,  -1.064846
tan(2.324900) =  -0.000000,  -1.064633
tan(2.325000) =  -0.000000,  -1.064419
tan(2.325100) =  -0.000000,  -1.064206
tan(2.325200) =  -0.000000,  -1.063993
tan(2.325300) =  -0.000000,  -1.063780
tan(2.325400) =  -0.000000,  -1.063567
tan(2.325500) =  -0.000000,  -1.063353
tan(2.325600) =  -0.000000,  -1.063140
tan(2.325700) =  -0.000000,  -1.062927
tan(2.325800) =  -0.000000,  -1.062714
tan(2.325900) =  -0.000000,  -1.062502
tan(2.326000) =  -0.000000,  -1.062289
tan(2.326100) =  -0.000000,  -1.062076
tan(2.326200) =  -0.000000,  -1.061863
tan(2.326300) =  -0.000000,  -1.061650
tan(2.326400) =  -0.000000,  -1.061438
tan(2.326500) =  -0.000000,  -1.061225
tan(2.326600) =  -0.000000,  -1.061012
tan(2.326700) =  -0.000000,  -1.060800
tan(2.326800) =  -0.000000,  -1.060587
tan(2.326900) =  -0.000000,  -1.060375
tan(2.327000) =  -0.000000,  -1.060162
tan(2.327100) =  -0.000000,  -1.059950
tan(2.327200) =  -0.000000,  -1.059738
tan(2.327300) =  -0.000000,  -1.059526
tan(2.327400) =  -0.000000,  -1.059313
tan(2.327500) =  -0.000000,  -1.059101
tan(2.327600) =  -0.000000,  -1.058889
tan(2.327700) =  -0.000000,  -1.058677
tan(2.327800) =  -0.000000,  -1.058465
tan(2.327900) =  -0.000000,  -1.058253
tan(2.328000) =  -0.000000,  -1.058041
tan(2.328100) =  -0.000000,  -1.057829
tan(2.328200) =  -0.000000,  -1.057617
tan(2.328300) =  -0.000000,  -1.057405
tan(2.328400) =  -0.000000,  -1.057193
tan(2.328500) =  -0.000000,  -1.056982
tan(2.328600) =  -0.000000,  -1.056770
tan(2.328700) =  -0.000000,  -1.056558
tan(2.328800) =  -0.000000,  -1.056347
tan(2.328900) =  -0.000000,  -1.056135
tan(2.329000) =  -0.000000,  -1.055924
tan(2.329100) =  -0.000000,  -1.055712
tan(2.329200) =  -0.000000,  -1.055501
tan(2.329300) =  -0.000000,  -1.055289
tan(2.329400) =  -0.000000,  -1.055078
tan(2.329500) =  -0.000000,  -1.054867
tan(2.329600) =  -0.000000,  -1.054655
tan(2.329700) =  -0.000000,  -1.054444
tan(2.329800) =  -0.000000,  -1.054233
tan(2.329900) =  -0.000000,  -1.054022
tan(2.330000) =  -0.000000,  -1.053811
tan(2.330100) =  -0.000000,  -1.053600
tan(2.330200) =  -0.000000,  -1.053389
tan(2.330300) =  -0.000000,  -1.053178
tan(2.330400) =  -0.000000,  -1.052967
tan(2.330500) =  -0.000000,  -1.052756
tan(2.330600) =  -0.000000,  -1.052545
tan(2.330700) =  -0.000000,  -1.052335
tan(2.330800) =  -0.000000,  -1.052124
tan(2.330900) =  -0.000000,  -1.051913
tan(2.331000) =  -0.000000,  -1.051703
tan(2.331100) =  -4.215009,  -1.051492
tan(2.331200) =  40.244047,  -1.051281
tan(2.331300) =  40.406394,  -1.051071
tan(2.331400) =  40.570056,  -1.050860
tan(2.331500) =  40.735049,  -1.050650
tan(2.331600) =  40.901388,  -1.050440
tan(2.331700) =  41.069092,  -1.050229
tan(2.331800) =  41.238176,  -1.050019
tan(2.331900) =  41.408658,  -1.049809
tan(2.332000) =  -4.203771,  -1.049599
tan(2.332100) =  41.753884,  -1.049389
tan(2.332200) =  -4.201281,  -1.049178
tan(2.332300) =  -4.200037,  -1.048968
tan(2.332400) =  42.282651,  -1.048758
tan(2.332500) =  -4.197552,  -1.048548
tan(2.332600) =  -4.196310,  -1.048338
tan(2.332700) =  42.824980,  -1.048129
tan(2.332800) =  -4.193828,  -1.047919
tan(2.332900) =  -4.192589,  -1.047709
tan(2.333000) =  43.381398,  -1.047499
tan(2.333100) =  -4.190111,  -1.047290
tan(2.333200) =  -4.188874,  -1.047080
tan(2.333300) =  43.952463,  -1.046870
tan(2.333400) =  44.146173,  -1.046661
tan(2.333500) =  44.341598,  -1.046451
tan(2.333600) =  44.538761,  -1.046242
tan(2.333700) =  -4.182696,  -1.046032
tan(2.333800) =  -4.181462,  -1.045823
tan(2.333900) =  45.140908,  -1.045613
tan(2.334000) =  45.345258,  -1.045404
tan(2.334100) =  -4.177766,  -1.045195
tan(2.334200) =  45.759558,  -1.044986
tan(2.334300) =  -4.175305,  -1.044776
tan(2.334400) =  46.181497,  -1.044567
tan(2.334500) =  -4.172847,  -1.044358
tan(2.334600) =  -4.171619,  -1.044149
tan(2.334700) =  -4.170391,  -1.043940
tan(2.334800) =  47.049153,  -1.043731
tan(2.334900) =  47.271184,  -1.043522
tan(2.335000) =  -0.000000,  -1.043313
tan(2.335100) =  -0.000000,  -1.043105
tan(2.335200) =  -0.000000,  -1.042896
tan(2.335300) =  -0.000000,  -1.042687
tan(2.335400) =  -0.000000,  -1.042478
tan(2.335500) =  -0.000000,  -1.042270
tan(2.335600) =  -0.000000,  -1.042061
tan(2.335700) =  -0.000000,  -1.041853
tan(2.335800) =  -0.000000,  -1.041644
tan(2.335900) =  -0.000000,  -1.041436
tan(2.336000) =  -0.000000,  -1.041227
tan(2.336100) =  -0.000000,  -1.041019
tan(2.336200) =  -0.000000,  -1.040810
tan(2.336300) =  -0.000000,  -1.040602
tan(2.336400) =  -0.000000,  -1.040394
tan(2.336500) =  -0.000000,  -1.040186
tan(2.336600) =  -0.000000,  -1.039977
tan(2.336700) =  -0.000000,  -1.039769
tan(2.336800) =  -0.000000,  -1.039561
tan(2.336900) =  -0.000000,  -1.039353
tan(2.337000) =  -0.000000,  -1.039145
tan(2.337100) =  -0.000000,  -1.038937
tan(2.337200) =  -0.000000,  -1.038729
tan(2.337300) =  -0.000000,  -1.038521
tan(2.337400) =  -0.000000,  -1.038314
tan(2.337500) =  -0.000000,  -1.038106
tan(2.337600) =  -0.000000,  -1.037898
tan(2.337700) =  -0.000000,  -1.037690
tan(2.337800) =  -0.000000,  -1.037483
tan(2.337900) =  -0.000000,  -1.037275
tan(2.338000) =  -0.000000,  -1.037067
tan(2.338100) =  -0.000000,  -1.036860
tan(2.338200) =  -0.000000,  -1.036652
tan(2.338300) =  -0.000000,  -1.036445
tan(2.338400) =  -0.000000,  -1.036238
tan(2.338500) =  -0.000000,  -1.036030
tan(2.338600) =  -0.000000,  -1.035823
tan(2.338700) =  -0.000000,  -1.035616
tan(2.338800) =  -0.000000,  -1.035408
tan(2.350600) =   0.000000,  -1.011252
tan(2.350700) =   0.000000,  -1.011050
tan(2.350800) =   0.000000,  -1.010848
tan(2.350900) =   0.000000,  -1.010645
tan(2.351000) =   0.000000,  -1.010443
tan(2.351100) =   0.000000,  -1.010241
tan(2.351200) =   0.000000,  -1.010039
tan(2.351300) =   0.000000,  -1.009837
tan(2.351400) =   0.000000,  -1.009635
tan(2.351500) =   0.000000,  -1.009433
tan(2.351600) =   0.000000,  -1.009231
tan(2.351700) =   0.000000,  -1.009030
tan(2.351800) =   0.000000,  -1.008828
tan(2.351900) =   0.000000,  -1.008626
tan(2.352000) =   0.000000,  -1.008424
tan(2.352100) =   0.000000,  -1.008223
tan(2.352200) =   0.000000,  -1.008021
tan(2.352300) =   0.000000,  -1.007819
tan(2.352400) =   0.000000,  -1.007618
tan(2.352500) =   0.000000,  -1.007416
tan(2.352600) =   0.000000,  -1.007215
tan(2.352700) =   0.000000,  -1.007014
tan(2.352800) =   0.000000,  -1.006812
tan(2.352900) =   0.000000,  -1.006611
tan(2.353000) =   0.000000,  -1.006409
tan(2.353100) =   0.000000,  -1.006208
tan(2.353200) =   0.000000,  -1.006007
tan(2.353300) =   0.000000,  -1.005806
tan(2.353400) =   0.000000,  -1.005605
tan(2.353500) =   0.000000,  -1.005404
tan(2.353600) =   0.000000,  -1.005202
tan(2.353700) =   0.000000,  -1.005001
tan(2.353800) =   0.000000,  -1.004800
tan(2.353900) =   0.000000,  -1.004600
tan(2.354000) =   0.000000,  -1.004399
tan(2.354100) =   0.000000,  -1.004198
tan(2.354200) =   0.000000,  -1.003997
tan(2.354300) =   0.000000,  -1.003796
tan(2.354400) =   0.000000,  -1.003595
#+END_CODE

* Bugs in C Standard Library Implementation

$$\textit{eglibc-2.14/libc/math/e_exp10.c}$$

# [[./img/eglibc_implementation.png]]

#+BEGIN_CODE
#include &lt;math.h&gt;
#include "math_private.h"

double
__ieee754_exp10 (double arg)
{
  /* This is a very stupid and inprecise implementation.  It'll get
     replaced sometime (soon?).  */
  return __ieee754_exp (M_LN10 * arg);
}
#+END_CODE
* Contamination
#+BEGIN_CODE
infrastructure/trocs/widgets/LidarViewer.cc:115:26:   const double y = sin(lastScan_[i].azimuth_rad + M_PI / 2) * lastScan_[i].range_m;
infrastructure/trocs/widgets/MissionPlanningTool.cc:1260:65:   glVertex3d(1.5*cos(degrees*0.0174532925)+2, 1.5*sin(degrees*0.0174532925)+2, 0-1);
infrastructure/trocs/widgets/DriveCommandDisplay.cc:116:65:   glVertex2d(radius - cos(i / 180.0 * M_PI) * radius, sin(i / 180.0 * M_PI) * fabs(radius));
infrastructure/trocs/widgets/LidarDisplay3D.cc:77:29:   laserPt.y = sin(ls[jj].azimuth_rad)*ls[jj].range_m * cos(ls[jj].elevation_rad);
infrastructure/trocs/widgets/LidarDisplay3D.cc:78:46:   laserPt.z = ls[jj].range_m * sin(ls[jj].elevation_rad);
infrastructure/trocs/widgets/RoadBlockageDisplay.cc:278:34:   radius * sin((float)ii / (float)npoints * (2 * M_PI)) );
infrastructure/trocs/widgets/RoadBlockageDisplay.cc:285:47:   glVertex2f( radius * cos(0), radius * sin(0) );
infrastructure/trocs/widgets/RoadBlockageDisplay.cc:286:50:   glVertex2f( radius * cos(M_PI), radius * sin(M_PI) );
infrastructure/trocs/widgets/VelodyneByLaserDrawable.cc:81:25:   laserPt.y = sin(mm->azimuth_rad)*mm->range_m * cos(mm->elevation_rad);
infrastructure/trocs/widgets/VelodyneByLaserDrawable.cc:82:39:   laserPt.z = mm->range_m * sin(mm->elevation_rad);
infrastructure/trocs/widgets/VehStateDisplay.cc:531:70:   glVertex2d(pos.x+cos(rr)*distance, pos.y+sin(rr)*distance);
infrastructure/trocs/widgets/VehStateDisplay.cc:621:46:   RecVector2D dir(cos(centerPose.rot1),sin(centerPose.rot1));
infrastructure/trocs/widgets/PathDisplay.cc:481:66:   color[0] = 0.5 + 0.5*sin(2*M_PI*(double)trajIndex/(double)(numTrajectories*2));
infrastructure/trocs/widgets/PathDisplay.cc:482:66:   color[1] = 0.5 + 0.5*sin(2*M_PI*(double)trajIndex/((double)numTrajectories*2) + 2);
infrastructure/trocs/widgets/PathDisplay.cc:483:66:   color[2] = 0.5 + 0.5*sin(2*M_PI*(double)trajIndex/((double)numTrajectories*2) + 4);
infrastructure/trocs/widgets/PathDisplay.cc:574:58:   color[0] = 0.5 + 0.5*sin(2*M_PI*(double)trajIndex/(double)(numTrajectories*2));
infrastructure/trocs/widgets/PathDisplay.cc:575:58:   color[1] = 0.5 + 0.5*sin(2*M_PI*(double)trajIndex/((double)numTrajectories*2) + 2);
infrastructure/trocs/widgets/PathDisplay.cc:576:58:   color[2] = 0.5 + 0.5*sin(2*M_PI*(double)trajIndex/((double)numTrajectories*2) + 4);
infrastructure/trocs/widgets/PathDisplay.cc:638:58:   color[0] = 0.5 + 0.5*sin(2*M_PI*(double)trajIndex/(double)(numTrajectories*2));
infrastructure/trocs/widgets/PathDisplay.cc:639:58:   color[1] = 0.5 + 0.5*sin(2*M_PI*(double)trajIndex/((double)numTrajectories*2) + 2);
infrastructure/trocs/widgets/PathDisplay.cc:640:58:   color[2] = 0.5 + 0.5*sin(2*M_PI*(double)trajIndex/((double)numTrajectories*2) + 4);
infrastructure/trocs/widgets/PathDisplay.cc:735:38:   color[0] = 0.5 + 0.5*sin(2*M_PI*(double)i/(double)(numGoals*2));
infrastructure/trocs/widgets/PathDisplay.cc:736:38:   color[1] = 0.5 + 0.5*sin(2*M_PI*(double)i/((double)numGoals*2) + 2);
infrastructure/trocs/widgets/PathDisplay.cc:737:38:   color[2] = 0.5 + 0.5*sin(2*M_PI*(double)i/((double)numGoals*2) + 4);
infrastructure/trocs/widgets/PointCloudViewer.cc:617:25:   laserPt.y = sin(ls[jj].azimuth_rad)*ls[jj].range_m;
infrastructure/trocs/widgets/PointCloudViewer.cc:874:25:   laserPt.y = sin(ls[jj].azimuth_rad)*ls[jj].range_m;
infrastructure/trocs/widgets/PointCloudViewer.cc:2143:39:   eyevector.x=camzoom[screenNumber]*sin(camphi_)*cos(camtheta_);
infrastructure/trocs/widgets/PointCloudViewer.cc:2144:39:   eyevector.y=camzoom[screenNumber]*sin(camphi_)*sin(camtheta_);
infrastructure/trocs/widgets/LidarCalib/LidarCalib.cc:146:16:   pt.y = sin(r.azimuth_rad)*r.range_m * cos(r.elevation_rad);
infrastructure/trocs/widgets/LidarCalib/LidarCalib.cc:147:28:   pt.z = r.range_m * sin(r.elevation_rad);
infrastructure/trocs/widgets/MotionCommandsDisplay.cc:335:25:   heading.y = scale * sin(goal.rotZ);
infrastructure/trocs/widgets/StandardLayerCamera.cc:127:34:   cameraOffset_.x += sin(cameraOffset_.rotZ) * dY;
infrastructure/trocs/widgets/StandardLayerCamera.cc:131:34:   cameraOffset_.y -= sin(cameraOffset_.rotZ) * dX;
infrastructure/trocs/widgets/UtilityLayers.cc:223:29:   double yy = sin(2.0 * PI * colorPerFacet * (double) ii);
infrastructure/trocs/widgets/SafeTracDisplay.cc:99:33:   offset.y = radius * sin(theta);
infrastructure/trocs/widgets/SafeTracDisplay.cc:178:35:   offsetPt.y = radius * sin(theta);
infrastructure/trocs/widgets/DrawRoad.cc:60:35:   RecPoint2D dir(cos(pose.rotZ),sin(pose.rotZ));
infrastructure/trocs/widgets/DrawRoad.cc:82:35:   RecPoint2D dir(cos(pose.rotZ),sin(pose.rotZ));
infrastructure/trocs/widgets/DrawRoad.cc:699:18:   laneOffset.x=sin(rotZ)*-1.0*(0.5+5.0*numLanes);
infrastructure/trocs/widgets/DrawRoad.cc:719:11:   dir.y=sin(pose.rotZ);
infrastructure/trocs/widgets/DrawRoad.cc:844:36:   RecVector2D dir(cos(pose.rotZ),sin(pose.rotZ));
infrastructure/trocs/widgets/DrawRoad.cc:992:75:   glVertex3d(scale*cos(degrees*dToR_)+p.x-renderOffset.x, scale*sin(degrees*dToR_)+p.y-renderOffset.y, 0-renderOffset.z);
infrastructure/trocs/widgets/DrawRoad.cc:1026:75:   glVertex3d(scale*cos(degrees*dToR_)+p.x-renderOffset.x, scale*sin(degrees*dToR_)+p.y-renderOffset.y, 0-renderOffset.z);
interfaces/PointSource/Input/PointedLineScanner/Impl.cc:112:50:   sensorPoint.y = lr.range_m * sin( lr.azimuth_rad );
perception/LaneMarkerDetectorAux/LaneMarkerDetectorAuxCG.cc:333:31:   double sinTheta = sin( lines[ ln ].theta );
perception/LaneMarkerDetectorAux/LaneMarkerDetectorAuxWZ.cc:270:79:   projectionDist = ptIter->x * cos(curLine.theta) + ptIter->y * sin(curLine.theta) - curLine.rho;
perception/LaneMarkerDetectorAux/LaneMarkerDetectorAuxWZ.cc:338:56:   int EdgeOffsetY = (int) round(filterScaleDist_*sin(angle));
perception/LaneMarkerDetectorAux/LaneMarkerDetectorAuxWZ.cc:480:35:   double sinTheta = sin(curLine.theta);
perception/LaneMarkerDetectorAux/LaneMarkerDetectorAuxWZ.cc:482:37:   double sinTheta90 = sin(curLine.theta-PI/2);
perception/ApplanixTask/ApplanixTask.cc:411:75:   * sin(ll.v);
perception/ApplanixTask/review/20070806/ApplanixTask.cc:375:82:   300 * sin(ll.v);
perception/HoughRoads/hough.cpp:49:64:   curRho = xVals[ptI] * cos(curTheta) + yVals[ptI] * sin(curTheta);
perception/HoughRoads/hough.cpp:89:68:   curRho = xVals[ptI] * cos(curTheta) + yVals[ptI] * sin(curTheta) + widths[widthI];
perception/HoughRoads/hough.cpp:433:58:   curR = xVals[ptA] * cos(curTheta) + yVals[ptA] * sin(curTheta) - curWidth / 2;
perception/VisibilityMap/VisibilityMapBuilder.cc:445:76:   yy = vehiclePose2D.y + visibilityMapVelodyneReliableRange_m_ * sin(increment);
perception/VisibilityMap/review/20070827/VisibilityMapBuilder.cc:388:87:   308 yy = vehiclePose2D.y + visibilityMapVelodyneReliableRange_m_ * sin(increment);
perception/OcclusionHypothesizer/OcclusionHypothesizer.cc:320:69:   RecDifferentialPose2D(cos(pose.rotZ) * speed_mps, sin(pose.rotZ) * speed_mps, 0),
perception/OcclusionHypothesizer/OcclusionHypothesizer.cc:341:37:   RecVector2D dir(cos(pose.rotZ), sin(pose.rotZ));
perception/LaneMarkerDetector/LaneMarkerDetector.cc:454:56:   int EdgeOffsetY = (int) round(filterScaleDist_*sin(angle));
perception/LaneMarkerDetector/LaneMarkerDetector.cc:568:35:   double sinTheta = sin(curLine.theta);
perception/LaneMarkerDetector/LaneMarkerDetector.cc:570:37:   double sinTheta90 = sin(curLine.theta-PI/2);
perception/VelodyneSegmenter/testQuickTrig.cc:14:28:   << QuickTrig::sin( ii * M_PI/180 )
perception/VelodyneSegmenter/quickTrig.h:21:25:   static inline float sin(float x) { return sinLookup_[(unsigned int) ( ( x + 4 * M_PI ) * convertFactor_)]; };
perception/VelodyneSegmenter/CarClassifier.cc:176:23:   double sinTheta = sin(thetaLong);
perception/VelodyneSegmenter/VelodyneSegmenter.cc:590:42:   segPt.localPt.y = QuickTrig::sin(ls[idx].azimuth_rad)*ls[idx].range_m * QuickTrig::cos(ls[idx].elevation_rad);
perception/VelodyneSegmenter/VelodyneSegmenter.cc:591:60:   segPt.localPt.z = ls[idx].range_m * QuickTrig::sin(ls[idx].elevation_rad);
perception/VelodyneViewer/int_calibrate.cpp:129:27:   // [r*cos(theta), r*sin(theta), r, 1.0, r, theta, cos(theta), sin(theta)]
perception/VelodyneViewer/int_calibrate.cpp:142:57:   data[ 8 * _M + 1 ] = r * ( data[ 8 * _M + 7 ] = sin( theta ) );
perception/VelodyneViewer/int_calibrate.cpp:290:27:   // [r*cos(theta), r*sin(theta), r, 1.0, r, theta, cos(theta), sin(theta)]
perception/VelodyneViewer/int_calibrate.cpp:304:27:   double sintheta = sin( theta );
perception/VelodyneViewer/int_calibrate.cpp:515:39:   data[ 1 ] = r * ( data[ 7 ] = sin( theta ) );
perception/VelodyneViewer/int_calibrate.cpp:546:27:   // data[ 1 ] = r sin(theta)
perception/VelodyneViewer/int_calibrate.cpp:552:25:   // data[ 7 ] = sin(theta)
perception/VelodyneViewer/int_calibrate.cpp:557:55:   data[ 8 * n + 1 ] = r * ( data[ 8 * n + 7 ] = sin( theta ) );
perception/VelodyneViewer/int_calibrate.cpp:981:36:   double sinElevation = sin( elevation );
perception/VelodyneViewer/int_calibrate.cpp:997:64:   b * r * cosElevation * sin( azimuthOffset + theta ) +
perception/VelodyneViewer/int_calibrate.cpp:1284:36:   double sinElevation = sin( elevation );
perception/VelodyneViewer/int_calibrate.cpp:1303:70:   b1 * r * cosElevation * sin( azimuthOffset + theta ) +
perception/VelodyneViewer/int_calibrate.cpp:1312:61:   b2 * r * cosElevation * sin( azimuthOffset + theta ) +
perception/VelodyneViewer/int_calibrate.cpp:1602:28:   double sinElevation = sin( elevation );
perception/VelodyneViewer/int_calibrate.cpp:1611:42:   b * r * cosElevation * sin( azimuthOffset + theta ) +
perception/VelodyneViewer/int_calibrate.cpp:1747:36:   double sinElevation = sin( elevation );
perception/VelodyneViewer/int_calibrate.cpp:1762:52:   double y = -r * cosElevation * sin( theta - azimuthOffset );
perception/VelodyneViewer/int_calibrate.cpp:1769:53:   b1 * r * cosElevation * sin( theta - azimuthOffset ) +
perception/VelodyneViewer/int_calibrate.cpp:1777:53:   b2 * r * cosElevation * sin( theta - azimuthOffset ) +
perception/VelodyneViewer/int_calibrate.cpp:2300:39:   aziOffsetCopyY.push_back( sin( angles[ 2 * i + 0 ] ) );
perception/VelodyneViewer/int_calibrate.cpp:2354:51:   plane[ 0 ] = cos( medianAziOffset ) * a - sin( medianAziOffset ) * b;
perception/VelodyneViewer/int_calibrate.cpp:2355:22:   plane[ 1 ] = sin( medianAziOffset ) * a + cos( medianAziOffset ) * b;
perception/VelodyneViewer/drawableAxis.h:111:16:   y = radius*sin(angle);
perception/VelodyneViewer/drawableAxis.h:125:16:   y = radius*sin(angle);
perception/VelodyneViewer/drawableAxis.h:138:20:   y = 0.5*radius*sin(angle);
perception/VelodyneViewer/drawableAxis.h:152:20:   y = 0.5*radius*sin(angle);
perception/VelodyneViewer/recGeometry/recTransform3D.cpp:167:8:   sa = sin(pose.rot1);
perception/VelodyneViewer/recGeometry/recTransform3D.cpp:168:8:   sb = sin(pose.rot2);
perception/VelodyneViewer/recGeometry/recTransform3D.cpp:169:8:   sg = sin(pose.rot3);
perception/VelodyneViewer/recGeometry/recTransform3D.cpp:479:13:	double s = sin(double(radAngle));
perception/VelodyneViewer/recGeometry/recTransform3D.cpp:502:13:	double s = sin(double(radAngle));
perception/VelodyneViewer/recGeometry/recTransform3D.cpp:525:13:	double s = sin(double(radAngle));
perception/VelodyneViewer/recGeometry/recPolygon2D.cpp:660:10:   st = sin(theta);
perception/VelodyneViewer/recGeometry/recPolygon2D.cpp:692:8:   st = sin(bestTheta);
perception/VelodyneViewer/recGeometry/recTransform2D.cpp:64:8:   sa = sin(pose.rotZ);
perception/VelodyneViewer/recGeometry/recTransform2D.cpp:165:13:	double s = sin(double(radAngle));
perception/VelodyneViewer/recGeometry/recPose3D.cpp:109:10:   sb = sin(rot2);
perception/VelodyneViewer/recGeometry/recPose3D.cpp:145:10:   sb = sin(rot2);
perception/VelodyneViewer/recGeometry/recPose3D.cpp:181:10:   sb = sin(rot2);
perception/VelodyneViewer/recGeometry/recPose3D.cpp:235:8:		sb = sin(rot2);
perception/VelodyneViewer/recGeometry/recPose3D.cpp:271:8:		sb = sin(rot2);
perception/VelodyneViewer/recGeometry/recPose3D.cpp:308:8:		sb = sin(rot2);
perception/VelodyneViewer/recGeometry/recQuaternion.cpp:241:13:   (*v) *= 1/sin(acos(quat[3]));
perception/VelodyneViewer/recGeometry/recQuaternion.cpp:255:8:   v *= sin(phi/2.0);
perception/VelodyneViewer/drawableImage.cpp:134:64:   double r = -a4 / ( a1 * cos( rawTheta ) + a2 * sin( rawTheta ) + a3 );
perception/VelodyneViewer/drawableImage.cpp:173:64:   double r = -a4 / ( a1 * cos( rawTheta ) + a2 * sin( rawTheta ) + a3 );
perception/VelodyneViewer/drawableImage.cpp:1277:21:   phiY += sin( fittedAngles[ i ][ 0 ] );
perception/VelodyneViewer/drawableImage.cpp:1285:21:   phiY += sin( fittedSecondaryAngles[ i ][ 0 ] );
perception/VelodyneViewer/velodyneInterface/velodyneInterface.cpp:169:25:   Y = range * sin( theta ) * cos( phi );
perception/VelodyneViewer/velodyneInterface/velodyneInterface.cpp:170:25:   Z = range * sin( phi );
perception/VelodyneViewer/ext_calibrate.cpp:24:17:   double sa = sin( rpy[ 2 ] );
perception/VelodyneViewer/ext_calibrate.cpp:26:17:   double sb = sin( rpy[ 1 ] );
perception/VelodyneViewer/ext_calibrate.cpp:28:17:   double sc = sin( rpy[ 0 ] );
perception/VelodyneViewer/ext_calibrate.cpp:118:37:   scaleFactor = 0.5 * theta / sin( theta );
perception/VelodyneViewer/ext_calibrate.cpp:629:30:// SE2 matrix is { cos(t), sin(t), x }, we just call atan2.
perception/VelodyneViewer/ext_calibrate.cpp:753:36:   double ct = cos( theta ), st = sin( theta );
perception/VelodyneViewer/ext_calibrate.cpp:1627:36:   // x = { tx, ty, cos(theta), sin(theta) }.
perception/VelodyneViewer/ext_calibrate.cpp:1636:24:   relSE2[ 0 ][ 1 ] = sin( theta );
perception/VelodyneViewer/ext_calibrate.cpp:1638:25:   relSE2[ 1 ][ 0 ] = -sin( theta );
perception/VelodyneViewer/trackballWindow/drawableAxis.h:120:17:   yy = radius*sin(angle);
perception/VelodyneViewer/trackballWindow/drawableAxis.h:134:17:   yy = radius*sin(angle);
perception/VelodyneViewer/trackballWindow/drawableAxis.h:147:21:   yy = 0.5*radius*sin(angle);
perception/VelodyneViewer/trackballWindow/drawableAxis.h:161:21:   yy = 0.5*radius*sin(angle);
perception/VelodyneViewer/trackballWindow/trackball.cpp:83:16:   phi = 2.0 * asin(t);
perception/VelodyneViewer/ext_calibrate_gslmm.cpp:28:17:   double sa = sin( rpy[ 2 ] );
perception/VelodyneViewer/ext_calibrate_gslmm.cpp:30:17:   double sb = sin( rpy[ 1 ] );
perception/VelodyneViewer/ext_calibrate_gslmm.cpp:32:17:   double sc = sin( rpy[ 0 ] );
perception/VelodyneViewer/ext_calibrate_gslmm.cpp:52:17:   double sa = sin( rpy[ 2 ] );
perception/VelodyneViewer/ext_calibrate_gslmm.cpp:54:17:   double sb = sin( rpy[ 1 ] );
perception/VelodyneViewer/ext_calibrate_gslmm.cpp:56:17:   double sc = sin( rpy[ 0 ] );
perception/VelodyneViewer/ext_calibrate_gslmm.cpp:146:37:   scaleFactor = 0.5 * theta / sin( theta );
perception/VelodyneViewer/ext_calibrate_gslmm.cpp:229:37:   scaleFactor = 0.5 * theta / sin( theta );
perception/VelodyneViewer/ext_calibrate_gslmm.cpp:740:30:// SE2 matrix is { cos(t), sin(t), x }, we just call atan2.
perception/VelodyneViewer/ext_calibrate_gslmm.cpp:864:36:   double ct = cos( theta ), st = sin( theta );
perception/RoadShapeFuser/RoadShapeFuser.cc:904:32:   tmpPose2D.y += sin(poses.back().rotZ);
perception/RoadShapeFuser/RoadShapeFuser.cc:3495:18:   tmpPose2D.y+=sin(localPose2D.rotZ);
perception/RoadShapeFuser/PFRoadModel.cc:638:16:   s_t += sin((*itr)->phi)*weight;
perception/RoadShapeFuser/PFRoadModel.cc:866:9:   sin(particles_[indMaxWeight]->phi)*v + particles_[indMaxWeight]->x;
perception/RoadShapeFuser/PFRoadModel.cc:868:9:   sin(particles_[indMaxWeight]->phi)*u + particles_[indMaxWeight]->y;
perception/RoadShapeFuser/PFRoadModel.cc:889:46:   curX = cos(particles_[idx]->phi)* u -sin(particles_[idx]->phi)*v + particles_[idx]->x;
perception/RoadShapeFuser/PFRoadModel.cc:890:46:   curY = cos(particles_[idx]->phi)* v +sin(particles_[idx]->phi)*u + particles_[idx]->y;
perception/RoadShapeFuser/PFRoadModel.cc:898:24:   s_t += sin(particles_[idx]->phi)*particles_[idx]->weight;
perception/MovingObstacleFuser/DATMOSensor.cc:2101:35:   boundaryPoint[bCounter].y=sin(actAngle);
perception/MovingObstacleFuser/PointTargetSensor.cc:306:29:   double sin2=pow(sin(sensorDifferentialPose.rotZ),2);
perception/MovingObstacleFuser/MultiSensorMovingObstacleFuser.cc:1924:53:   r->sensorDifferentialPose.y=sin(currentVehicleState.pose.rot1)*currentVehicleState.speed_mps;
perception/MovingObstacleFuser/Filters.cc:364:32:   Fx(sXPOS,sYAW)= -1*x[sVEL]*sin(x[sYAW])*dt_ - 0.5f*x[sACC]*sin(x[sYAW])*dt_*dt_;
perception/MovingObstacleFuser/Filters.cc:369:21:   Fx(sYPOS,sVEL)= sin(x[sYAW])*dt_;
perception/MovingObstacleFuser/Filters.cc:370:26:   Fx(sYPOS,sACC)= 0.5f*sin(x[sYAW])*dt_*dt_;
perception/MovingObstacleFuser/Filters.cc:388:54:   fx_[sYPOS] += (fx_[sVEL] + 0.5f*fx_[sACC]*dt_) * sin(fx_[sYAW])*dt_;
perception/MovingObstacleFuser/Filters.cc:812:42:   zPred_[oYVEL]=x[SimpleBicycle::sVEL]*sin(x[sYAW]);
perception/MovingObstacleFuser/Filters.cc:823:37:   Hx(oXVEL,SimpleBicycle::sYAW )=-sin(x[SimpleBicycle::sYAW]);
perception/MovingObstacleFuser/Filters.cc:826:37:   Hx(oYVEL,SimpleBicycle::sVEL )= sin(x[SimpleBicycle::sYAW]);
perception/MovingObstacleFuser/Filters.cc:1064:72:   zPred_[oXPOS]= cos(angleSensor_)*(x[FreePointAcc::sXPOS]-xSensor_)+sin(angleSensor_)*(x[FreePointAcc::sYPOS]-ySensor_);
perception/MovingObstacleFuser/Filters.cc:1065:20:   zPred_[oYPOS]=-sin(angleSensor_)*(x[FreePointAcc::sXPOS]-xSensor_)+cos(angleSensor_)*(x[FreePointAcc::sYPOS]-ySensor_);
perception/MovingObstacleFuser/Filters.cc:1069:14:   +sin(angleSensor_)*(x[FreePointAcc::sYVEL]-vySensor_-vangleSensor_*(x[FreePointAcc::sXPOS]-xSensor_));
perception/MovingObstacleFuser/Filters.cc:1072:14:   -sin(angleSensor_)*(x[FreePointAcc::sXVEL]-vxSensor_+vangleSensor_*(x[FreePointAcc::sYPOS]-ySensor_))
perception/MovingObstacleFuser/Filters.cc:1085:38:   Hx(oXPOS,FreePointAcc::sYPOS) = sin(angleSensor_);
perception/MovingObstacleFuser/Filters.cc:1087:38:   Hx(oYPOS,FreePointAcc::sXPOS) = -sin(angleSensor_);
perception/MovingObstacleFuser/Filters.cc:1090:52:   Hx(oXVEL,FreePointAcc::sXPOS) = -vangleSensor_*sin(angleSensor_);
perception/MovingObstacleFuser/Filters.cc:1093:38:   Hx(oXVEL,FreePointAcc::sYVEL) = sin(angleSensor_);
perception/MovingObstacleFuser/Filters.cc:1096:52:   Hx(oYVEL,FreePointAcc::sYPOS) = -vangleSensor_*sin(angleSensor_);
perception/MovingObstacleFuser/Filters.cc:1097:38:   Hx(oYVEL,FreePointAcc::sXVEL) = -sin(angleSensor_);
perception/MovingObstacleFuser/Filters.cc:1182:50:   xTmp = cos(angleSensor_)*(x[sXPOS]-xSensor_)+sin(angleSensor_)*(x[sYPOS]-ySensor_);
perception/MovingObstacleFuser/Filters.cc:1183:12:   yTmp =-sin(angleSensor_)*(x[sXPOS]-xSensor_)+cos(angleSensor_)*(x[sYPOS]-ySensor_);
perception/MovingObstacleFuser/Filters.cc:1186:31:   double yVelGlobal=x[sVEL]*sin(x[sYAW]);
perception/MovingObstacleFuser/Filters.cc:1195:14:   +sin(angleSensor_)*(yVelGlobal-vySensor_-vangleSensor_*(x[sXPOS]-xSensor_));
perception/MovingObstacleFuser/Filters.cc:1198:14:   -sin(angleSensor_)*(xVelGlobal-vxSensor_+vangleSensor_*(x[sYPOS]-ySensor_))
perception/MovingObstacleFuser/Filters.cc:1206:79:   zPred_[oCORNERXPOS]=xTmp+cos(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f-sin(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1207:38:   zPred_[oCORNERYPOS]=yTmp+sin(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f+cos(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1210:79:   zPred_[oCORNERXPOS]=xTmp+cos(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f+sin(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1211:38:   zPred_[oCORNERYPOS]=yTmp+sin(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f-cos(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1214:79:   zPred_[oCORNERXPOS]=xTmp-cos(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f-sin(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1215:38:   zPred_[oCORNERYPOS]=yTmp-sin(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f+cos(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1218:79:   zPred_[oCORNERXPOS]=xTmp-cos(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f+sin(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1219:38:   zPred_[oCORNERYPOS]=yTmp-sin(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f-cos(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1223:38:   zPred_[oCORNERYPOS]=yTmp+sin(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1227:38:   zPred_[oCORNERYPOS]=yTmp-sin(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1230:38:   zPred_[oCORNERXPOS]=xTmp-sin(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1234:38:   zPred_[oCORNERXPOS]=xTmp+sin(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1265:30:   Hx(oCORNERXPOS,sYPOS) = sin(angleSensor_);
perception/MovingObstacleFuser/Filters.cc:1267:30:   Hx(oCORNERYPOS,sXPOS) = -sin(angleSensor_);
perception/MovingObstacleFuser/Filters.cc:1271:38:   Hx(oXVEL,sXPOS) = -vangleSensor_*sin(angleSensor_);
perception/MovingObstacleFuser/Filters.cc:1273:55:   Hx(oXVEL,sVEL) = cos(angleSensor_)*cos(x[sYAW])+sin(angleSensor_)*sin(x[sYAW]);
perception/MovingObstacleFuser/Filters.cc:1274:50:   Hx(oXVEL,sYAW) = -cos(angleSensor_)*x[sVEL]*sin(x[sYAW])+sin(angleSensor_)*x[sVEL]*cos(x[sYAW]);
perception/MovingObstacleFuser/Filters.cc:1277:38:   Hx(oYVEL,sYPOS) = -vangleSensor_*sin(angleSensor_);
perception/MovingObstacleFuser/Filters.cc:1278:24:   Hx(oYVEL,sVEL) = -sin(angleSensor_)*cos(x[sYAW])+cos(angleSensor_)*sin(x[sYAW]);
perception/MovingObstacleFuser/Filters.cc:1279:24:   Hx(oYVEL,sYAW) = +sin(angleSensor_)*x[sVEL]*sin(x[sYAW])+cos(angleSensor_)*x[sVEL]*cos(x[sYAW]);
perception/MovingObstacleFuser/Filters.cc:1285:35:   Hx(oCORNERXPOS,sYAW)=-sin(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f-cos(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1286:76:   Hx(oCORNERYPOS,sYAW)=+cos(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f-sin(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1289:35:   Hx(oCORNERXPOS,sYAW)=-sin(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f+cos(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1290:76:   Hx(oCORNERYPOS,sYAW)=+cos(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f+sin(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1293:35:   Hx(oCORNERXPOS,sYAW)=+sin(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f+cos(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1294:76:   Hx(oCORNERYPOS,sYAW)=-cos(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f+sin(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1297:35:   Hx(oCORNERXPOS,sYAW)=+sin(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f-cos(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1298:76:   Hx(oCORNERYPOS,sYAW)=-cos(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f-sin(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1301:35:   Hx(oCORNERXPOS,sYAW)=-sin(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1305:35:   Hx(oCORNERXPOS,sYAW)=+sin(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1310:35:   Hx(oCORNERYPOS,sYAW)=-sin(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1314:35:   Hx(oCORNERYPOS,sYAW)=+sin(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1650:42:   vel.y = v[SimpleBicycle::sVEL]*sin(v[SimpleBicycle::sYAW]);
perception/MovingObstacleFuser/Filters.cc:1717:49:   // ->this is wrong:   vx=v*cos(yaw), vy*sin(yaw) - linearize, then make an approximation.
perception/MovingObstacleFuser/Filters.cc:1815:58:   RecVector2D velocityError1(cos(tmp.rotZ)*std,sin(tmp.rotZ)*std); //assumed to be the worst case
perception/MovingObstacleFuser/Filters.cc:1816:63:   RecVector2D velocityError2(cos(tmp.rotZ+M_PI)*std,sin(tmp.rotZ+M_PI)*std); //assumed to be the worst case
perception/MovingObstacleFuser/Filters.cc:2335:51:   vel.y = this->operator()(SimpleBicycle::sVEL)*sin(yaw);
perception/MovingObstacleFuser/ARS300Sensor.cc:122:62:   RecVector2D sensorDirection(cos(sensorPose.rotZ),sin(sensorPose.rotZ));
perception/MovingObstacleFuser/ARS300Sensor.cc:195:54:   RecVector2D sensorDirection(cos(sensorPose.rotZ),sin(sensorPose.rotZ));
perception/MovingObstacleFuser/ARS300Sensor.cc:288:24:   boundaryPoint[0].y=sin(openingAngle);
perception/MovingObstacleFuser/ARS300Sensor.cc:293:24:   boundaryPoint[1].y=sin(-openingAngle);
perception/MovingObstacleFuser/ARS300Sensor.cc:298:24:   boundaryPoint[2].y=sin(-openingAngle);
perception/MovingObstacleFuser/ARS300Sensor.cc:303:24:   boundaryPoint[3].y=sin(+openingAngle);
perception/MovingObstacleFuser/ARS300Sensor.cc:383:53:   RecVector2D sensorAxis(cos(sensorPose.rotZ),sin(sensorPose.rotZ));
perception/MovingObstacleFuser/RoadShapeExtrapolator.cc:719:28:   velocities[ii].y = sin(poses[ii].rotZ)*speed_mps;
perception/MovingObstacleFuser/DummyMovingObjectSet.cc:218:11:   * sin(param.steerAngle_rad);
perception/MovingObstacleFuser/DummyMovingObjectSet.cc:221:26:   vel.y = linVel_mps * sin(param.pose.rotZ);
perception/RoadBlockageDetector/RoadBlockageDetector.cc:868:45:   RecVector2D dir(cos(pose.rotZ), sin(pose.rotZ));
perception/RoadBlockageDetector/RoadBlockageDetector.cc:977:37:   RecVector2D dir(cos(pose.rotZ), sin(pose.rotZ));
perception/modUtils/Linear.cc:73:38:   cos(phi) * cos(the) * cos(psi) + sin(phi) * sin(the) * sin(psi);
perception/modUtils/Linear.cc:75:5:   sin(phi) * cos(the) * cos(psi) - cos(phi) * sin(the) * sin(psi);
perception/modUtils/Linear.cc:77:16:   cos(phi) * sin(the) * cos(psi) + sin(phi) * cos(the) * sin(psi);
perception/modUtils/Linear.cc:79:27:   cos(phi) * cos(the) * sin(psi) - sin(phi) * sin(the) * cos(psi);
perception/modUtils/Linear.cc:89:12:   pitch = asin(-2*(quaternion[0]*quaternion[2] - quaternion[3]*quaternion[1]));
perception/modUtils/Linear.cc:253:19:   double radsin = sin( radians / 2 );
perception/modUtils/Linear.cc:276:30:   ** | u1 X u2 | = |u1||u2|sin(theta)
perception/modUtils/Linear.cc:280:20:   ** theta = arcsin(|axis|)
perception/modUtils/Linear.cc:287:24:   ** set it to 1 or asin() will barf.
perception/modUtils/Linear.cc:296:19:   double theta = asin( crossProductMagnitude ) ;
perception/modUtils/Linear.cc:475:18:   sinOmega = sin(omega);
perception/modUtils/Linear.cc:476:20:   startScale = sin((1.0 - t)*omega) / sinOmega;
perception/modUtils/Linear.cc:477:18:   endScale = sin(t*omega) / sinOmega;
perception/modUtils/Linear.cc:492:18:   startScale = sin((0.5 - t) * M_PI);
perception/modUtils/Linear.cc:493:16:   endScale = sin(t * M_PI);
perception/modUtils/Linear.cc:592:17:   double siny = sin(-yaw);
perception/modUtils/review/20070714/Linear.cc:73:45:   60 cos(phi) * cos(the) * cos(psi) + sin(phi) * sin(the) * sin(psi);
perception/modUtils/review/20070714/Linear.cc:75:12:   62 sin(phi) * cos(the) * cos(psi) - cos(phi) * sin(the) * sin(psi);
perception/modUtils/review/20070714/Linear.cc:77:23:   64 cos(phi) * sin(the) * cos(psi) + sin(phi) * cos(the) * sin(psi);
perception/modUtils/review/20070714/Linear.cc:79:34:   66 cos(phi) * cos(the) * sin(psi) - sin(phi) * sin(the) * cos(psi);
perception/modUtils/review/20070714/Linear.cc:89:19:   75 pitch = asin(-2*(quaternion[0]*quaternion[2] - quaternion[3]*quaternion[1]));
perception/modUtils/review/20070714/Linear.cc:253:26:   226 double radsin = sin( radians / 2 );
perception/modUtils/review/20070714/Linear.cc:276:37:   246 ** | u1 X u2 | = |u1||u2|sin(theta)
perception/modUtils/review/20070714/Linear.cc:280:27:   250 ** theta = arcsin(|axis|)
perception/modUtils/review/20070714/Linear.cc:287:31:   256 ** set it to 1 or asin() will barf.
perception/modUtils/review/20070714/Linear.cc:296:26:   264 double theta = asin( crossProductMagnitude ) ;
perception/modUtils/review/20070714/Linear.cc:475:25:   425 sinOmega = sin(omega);
perception/modUtils/review/20070714/Linear.cc:476:27:   426 startScale = sin((1.0 - t)*omega) / sinOmega;
perception/modUtils/review/20070714/Linear.cc:477:25:   427 endScale = sin(t*omega) / sinOmega;
perception/modUtils/review/20070714/Linear.cc:492:25:   442 startScale = sin((0.5 - t) * M_PI);
perception/modUtils/review/20070714/Linear.cc:493:23:   443 endScale = sin(t * M_PI);
perception/modUtils/review/20070714/Linear.cc:592:24:   520 double siny = sin(-yaw);
perception/modUtils/review/20070714/VehState.cc:39:22:   36 double sx = sin(heading_offset);
perception/modUtils/review/20070714/VehState.cc:56:22:   52 double sx = sin(-heading_offset);
perception/modUtils/review/20070714/Vec3d.cc:9:34:   6 x = cos(theta)*xorig + sin(theta)*y;
perception/modUtils/review/20070714/Vec3d.cc:10:15:   7 y = -sin(theta)*xorig + cos(theta)*y;
perception/modUtils/VehState.cc:39:15:   double sx = sin(heading_offset);
perception/modUtils/VehState.cc:56:15:   double sx = sin(-heading_offset);
perception/modUtils/Vec3d.cc:9:27:   x = cos(theta)*xorig + sin(theta)*y;
perception/modUtils/Vec3d.cc:10:8:   y = -sin(theta)*xorig + cos(theta)*y;
perception/ARS300Reader/review/20070715/ARS300Reader.cc:371:112:   341 target->absVelocitySensorCoord.x=vx+cos(angle)*sensorVx+sin(angle)*sensorVy;
perception/ARS300Reader/review/20070715/ARS300Reader.cc:372:92:   342 target->absVelocitySensorCoord.y=vy-sin(angle)*sensorVx+cos(angle)*sensorVy;
perception/ARS300Reader/ARS300Reader.cc:396:105:   target->absVelocitySensorCoord.x=vx+cos(angle)*sensorVx+sin(angle)*sensorVy;
perception/ARS300Reader/ARS300Reader.cc:397:85:   target->absVelocitySensorCoord.y=vy-sin(angle)*sensorVx+cos(angle)*sensorVy;
perception/GPSErrorEstimator/GPSErrorEstimator.cc:328:46:   signOfSpeed * sin(lastState_.pose.rot1)* deltaT * curSpeed
perception/GPSErrorEstimator/testGPSErrorMeasurementSource.cc:51:51:   RecVector2D perp(cos(laneCenter.rotZ+M_PI/2), sin(laneCenter.rotZ+M_PI/2));
perception/LidarIntensityLaneMarkerDetection/LidarIntensityLaneMarkerDetection.cc:852:12:   pt.y = sin(lr.azimuth_rad)*lr.range_m * cos(lr.elevation_rad);
perception/LidarIntensityLaneMarkerDetection/LidarIntensityLaneMarkerDetection.cc:853:25:   pt.z = lr.range_m * sin(lr.elevation_rad);
perception/GeometryCurbDetector/GeometryCurbDetector.cc:935:9:	pt.y = sin(lr.azimuth_rad)*lr.range_m * cos(lr.elevation_rad);
perception/GeometryCurbDetector/GeometryCurbDetector.cc:936:22:	pt.z = lr.range_m * sin(lr.elevation_rad);
simulator/statecontroller/src/generateenvironment.cpp:234:37:   TVector3D directionv(cos(angle),sin(angle),0 );
simulator/statecontroller/src/generateenvironment.cpp:318:37:   TVector3D directionv(cos(angle),sin(angle),0 );
simulator/viewer/src/SimView.cpp:372:28:   QuatD rotated(cos(angle),sin(angle),0,0);
simulator/viewer/src/SimView.cpp:729:27:   float sinTheta = (float)sin(angle);
simulator/viewer/src/visualizationloop.cpp:361:31:   QuatD ori(cos(angle2),0,0,sin(angle2));
simulator/viewer/src/interactwithworld.cpp:442:35:   TVector3D directionv(cos(angle),sin(angle),0 );
simulator/viewer/src/interactwithworld.cpp:456:39:   TVector3D directionvp(cos(anglep),sin(anglep),0 );
simulator/viewer/src/interactwithworld.cpp:458:38:   TVector3D directionv(cos(anglep),sin(anglep),0 );
simulator/viewer/src/interactwithworld.cpp:469:37:   directionv = TVector3D(cos(angle),sin(angle),0 );
simulator/viewer/src/interactwithworld.cpp:1148:37:   TVector3D directionv(cos(angle),sin(angle),0 );
simulator/viewer/src/interactwithworld.cpp:1189:37:   TVector3D directionv(cos(angle),sin(angle),0 );
simulator/viewer/src/terrain.cpp:555:20:   newy = (y/2+20)*sin(angle);
simulator/viewer/src/viewpositioning.cpp:161:28:   QuatD ori2(cos(angle3),0,sin(angle3),0);
simulator/viewer/src/viewpositioning.cpp:166:27:   QuatD ori(cos(angle2),0,sin(angle2),0);
simulator/robotclient/src/generaterobotpose.cpp:265:63:   return dp->getPosition() - TVector3D( ora*cos(heading), ora*sin(heading),0);
simulator/robotclient/src/generateobstaclemap.cpp:65:60:   TVector3D offset(cos(robotorientation[2]) * OFFSETDIST_m,sin(robotorientation[2]) * OFFSETDIST_m,0);
simulator/common/primitives/src/DynamicPrim.cpp:222:81:   v1[0]= TVector3D((l2 - m_offsetrearaxle)*cos(heading),(l2 - m_offsetrearaxle)*sin(heading),0);
simulator/common/primitives/src/DynamicPrim.cpp:223:83:   v1[1]= TVector3D(-(l2 + m_offsetrearaxle)*cos(heading),-(l2 + m_offsetrearaxle)*sin(heading),0);
simulator/common/primitives/src/DynamicPrim.cpp:225:59:   TVector3D widthdiff(TVector3D(w2*cos(heading+M_PI_2),w2*sin(heading+M_PI_2),0));
simulator/common/primitives/src/DynamicPrim.cpp:320:32:   position[1] += arcLength * sin(orientation[2]);
simulator/common/primitives/src/DynamicPrim.cpp:321:64:   m_velocity = TVector3D(m_speed*cos(orientation[2]),m_speed*sin(orientation[2]),0);
simulator/common/primitives/src/DynamicPrim.cpp:334:36:   double cy = position[1] + radius*sin(orientation[2]-sgn*M_PI/2.0);
simulator/common/primitives/src/DynamicPrim.cpp:340:29:   position[1] = cy + radius*sin(theta-phi);
simulator/common/primitives/src/DynamicPrim.cpp:348:62:   m_velocity = TVector3D(m_speed*cos(orientation[2]),m_speed*sin(orientation[2]),0);
simulator/common/primitives/src/DynamicPrim.cpp:359:81:   v1[0]= TVector3D((l2 - m_offsetrearaxle)*cos(heading),(l2 - m_offsetrearaxle)*sin(heading),0);
simulator/common/primitives/src/DynamicPrim.cpp:360:83:   v1[1]= TVector3D(-(l2 + m_offsetrearaxle)*cos(heading),-(l2 + m_offsetrearaxle)*sin(heading),0);
simulator/common/primitives/src/DynamicPrim.cpp:362:59:   TVector3D widthdiff(TVector3D(w2*cos(heading+M_PI_2),w2*sin(heading+M_PI_2),0));
simulator/common/primitives/src/AreaPrim.cpp:378:41:   directionv = TVector3D(cos(angle),sin(angle),0 );
simulator/common/primitives/src/AreaPrim.cpp:390:43:   directionv = TVector3D(cos(angle),sin(angle),0 );
simulator/math/math_tools.cpp:218:2:-sin(theta)*sin(psi)/(2*s)
simulator/math/math_tools.cpp:219:2:(sin(theta)*cos(psi)+sin(theta)) /(2*s)
simulator/math/math_tools.cpp:220:2:(sin(psi)*cos(theta)+sin(psi))/(2*s)*/
simulator/math/math_tools.cpp:278:23:   float x = from[0] * sin(from[1]) * cos(from[2]);
simulator/math/math_tools.cpp:279:23:   float y = from[0] * sin(from[1]) * sin(from[2]);
simulator/math/math_tools.cpp:287:40:   QuatD rot_psi(cos(vector[1]/2.0),0,0,sin(vector[1]/2.0));
simulator/math/math_tools.cpp:288:39:   //QuatD rot_psi(cos(-vector[1]/2.0),sin(-vector[1]/2.0),0,0);
simulator/math/math_tools.cpp:289:42:   QuatD rot_theta(cos((vector[2])/2.0),0,sin((vector[2])/2.0),0);
simulator/math/math_tools.cpp:349:35:   return QuatD(cos(heading/2.0),0,sin(heading/2.0),0);
simulator/math/math_tools.cpp:361:21:   QuatD pq(cos(p2), sin(p2), 0, 0);
simulator/math/math_tools.cpp:362:30:   QuatD rq(cos(r2), 0, sin(r2), 0);
simulator/math/math_tools.cpp:363:39:   QuatD yq(cos(y2), 0, 0, sin(y2));
simulator/math/math_tools.cpp:386:19:   double pitch = asin( arg1 );
simulator/math/math_tools.cpp:393:19:   double pitch = asin(arg1);
simulator/math/quaterniont.h:143:14:   b = (d = r*sin(phi)) * cos(theta);	// r*sin(phi)*cos(theta)
simulator/math/quaterniont.h:144:13:   c = (d *= sin(theta)) * cos(psi);	// r*sin(phi)*sin(theta)*cos(psi)
simulator/math/quaterniont.h:145:8:   d *= sin(psi);			// r*sin(phi)*sin(theta)*sin(psi)
utility/RailBot/RailBot.cc:421:48:   sin(pose.rotZ),
utility/RailBot/RailBot.cc:498:48:   sin(heading),
utility/VelodyneToXYZ/VelodyneToXYZ.cc:133:53:   << ", " << recentData_[i].range_m * sin(recentData_[i].azimuth_rad) * cos(recentData_[i].elevation_rad)
utility/VelodyneToXYZ/VelodyneToXYZ.cc:134:53:   << ", " << recentData_[i].range_m * sin(recentData_[i].elevation_rad)
utility/PurePursuitMotionPlanner/PurePursuitMotionPlannerTask.cc:116:81:   const RecVector2D currentHeadingVector(cos(currentVehicleState_.pose.rot1), sin(currentVehicleState_.pose.rot1));
utility/PurePursuitMotionPlanner/PurePursuitMotionPlannerTask.cc:185:40:   relativeLookAheadPoint.y = r * sin(a - currentVehicleState_.pose.rot1);
utility/PurePursuitMotionPlanner/PurePursuitMotionPlannerTask.cc:188:52:   newDriveCommand.desiredCurvature_k = 2.0 * sin(phi) / l;
utility/RndfCheckpointExtractor/rndfCheckpointExtractor.cc:63:42:   double n=eqRadius/sqrt(1.0-eccSq*sqr(sin(latRad)));
utility/RndfCheckpointExtractor/rndfCheckpointExtractor.cc:69:87:   - (3.0*eccSq/8.0 + 3.0*sqr(eccSq)/32.0 + 45.0*pow(eccSq,3)/1024.0)*sin(latRad*2.0)
utility/RndfCheckpointExtractor/rndfCheckpointExtractor.cc:70:73:   + (15.0*sqr(eccSq)/256.0 + 45.0*pow(eccSq,3)/1024.0)*sin(latRad*4.0)
utility/RndfCheckpointExtractor/rndfCheckpointExtractor.cc:71:49:   - (35.0*pow(eccSq,3)/3072.0)*sin(latRad*6.0) );
utility/purePursuit/purePursuitTask.cc:168:69:   const RecVector2D headingVector(cos(rearDiffPose.rot1), sin(rearDiffPose.rot1));
utility/purePursuit/purePursuitTask.cc:247:52:   newDriveCommand.desiredCurvature_k = 2.0 * sin(phi) / l;
utility/VelodyneToPoints/VelodyneToPoints.cc:92:21:   localPt.y = sin(ls[ii].azimuth_rad) * ls[ii].range_m * cos( ls[ii].elevation_rad );
utility/VelodyneToPoints/VelodyneToPoints.cc:93:38:   localPt.z = ls[ii].range_m * sin(ls[ii].elevation_rad);
behaviors/GeometricPrecedenceEstimator.cc:806:52:   const double minCrossProduct = sin(PI/180.0 * geometricYieldMinAngle_deg_);
behaviors/GoalSelector.cc:3429:53:   const double xDisp = 0.5 + wiggleMagnitude_m_ * sin(seconds); //. 0.5 + to bias forward motions so we have a statistical change of wiggling out from under a tree
behaviors/SineTestDriver.cc:39:28:   params.maxSpeed_mps += sin(t*2*M_PI)*amplitude_mps_;
common/LidarUtils/LidarUtils.cc:58:15:   point.y = sin(pPoint.azimuth_rad)*pPoint.range_m * cos(pPoint.elevation_rad);
common/LidarUtils/LidarUtils.cc:59:32:   point.z = pPoint.range_m * sin(pPoint.elevation_rad);
common/LidarUtils/review/20070712/LidarUtils.cc:58:22:   52 point.y = sin(pPoint.azimuth_rad)*pPoint.range_m * cos(pPoint.elevation_rad);
common/LidarUtils/review/20070712/LidarUtils.cc:59:39:   53 point.z = pPoint.range_m * sin(pPoint.elevation_rad);
common/RoadWorldModel/Intersection.cc:129:41:   RecVector2D dir(cos(pose.rotZ), sin(pose.rotZ));
common/RoadWorldModel/RndfBuilder.cc:2114:25:   double dy = sin(pose.rotZ);
common/RoadWorldModel/RndfBuilder.cc:2140:25:   double dy = sin(pose.rotZ);
common/RoadWorldModel/RndfBuilder.cc:2197:20:   pose.y+=sin(pose.rotZ)*0.1;
common/RoadWorldModel/RndfBuilder.cc:2245:20:   pose.y-=sin(pose.rotZ)*0.1;
common/RoadWorldModel/RndfBuilder.cc:2263:16:   pose.y+=sin(pose.rotZ)*0.1;
common/RoadWorldModel/RndfBuilder.cc:2272:16:   pose.y-=sin(pose.rotZ)*0.1;
common/RoadWorldModel/testLaneKd.cc:372:41:   RecPoint2D vec( 5 * cos(r), 5 * sin(r) );
common/recgeometry/recTransform3D.cpp:203:8:   sa = sin(pose.rot1);
common/recgeometry/recTransform3D.cpp:204:8:   sb = sin(pose.rot2);
common/recgeometry/recTransform3D.cpp:205:8:   sg = sin(pose.rot3);
common/recgeometry/recTransform3D.cpp:512:13:	double s = sin(double(radAngle));
common/recgeometry/recTransform3D.cpp:535:13:	double s = sin(double(radAngle));
common/recgeometry/recTransform3D.cpp:558:13:	double s = sin(double(radAngle));
common/recgeometry/rectangleFitter.def.h:87:71:	tmp.x = (hullPts[ii].x-midPt.x)*cos(theta) + (hullPts[ii].y-midPt.y)*sin(theta);
common/recgeometry/rectangleFitter.def.h:88:35:	tmp.y = -(hullPts[ii].x-midPt.x)*sin(theta) + (hullPts[ii].y-midPt.y)*cos(theta);
common/recgeometry/rectangleFitter.def.h:93:37:	itmp.x = (tmp.x*cos(theta))-(tmp.y*sin(theta))+midPt.x;
common/recgeometry/rectangleFitter.def.h:94:18:	itmp.y = (tmp.x*sin(theta))+(tmp.y*cos(theta))+midPt.y;
common/recgeometry/rectangleFitter.def.h:95:46:	inewTmp.x = (newTmp.x*cos(theta))-(newTmp.y*sin(theta))+midPt.x;
common/recgeometry/rectangleFitter.def.h:96:24:	inewTmp.y = (newTmp.x*sin(theta))+(newTmp.y*cos(theta))+midPt.y;
common/recgeometry/rectangleFitter.def.h:148:72:   double tempX = (txPts[jj].x * cos(theta)) + (txPts[jj].y * sin(theta));
common/recgeometry/rectangleFitter.def.h:149:72:   double tempY = (txPts[jj].y * cos(theta)) - (txPts[jj].x * sin(theta));
common/recgeometry/rectangleFitter.def.h:182:54:	rotTmp.x = (transTmp.x*cos(finalTheta))+(transTmp.y*sin(finalTheta));
common/recgeometry/rectangleFitter.def.h:183:26:	rotTmp.y = -(transTmp.x*sin(finalTheta))+(transTmp.y*cos(finalTheta));
common/recgeometry/rectangleFitter.def.h:197:56:   rectCoordinates[0].x = maxL*cos(finalTheta) - maxW*sin(finalTheta) + clusterMean.x;
common/recgeometry/rectangleFitter.def.h:198:33:   rectCoordinates[0].y = maxL*sin(finalTheta) + maxW*cos(finalTheta) + clusterMean.y;
common/recgeometry/rectangleFitter.def.h:200:56:   rectCoordinates[1].x = maxL*cos(finalTheta) - minW*sin(finalTheta) + clusterMean.x;
common/recgeometry/rectangleFitter.def.h:201:33:   rectCoordinates[1].y = maxL*sin(finalTheta) + minW*cos(finalTheta) + clusterMean.y;
common/recgeometry/rectangleFitter.def.h:203:56:   rectCoordinates[2].x = minL*cos(finalTheta) - minW*sin(finalTheta) + clusterMean.x;
common/recgeometry/rectangleFitter.def.h:204:33:   rectCoordinates[2].y = minL*sin(finalTheta) + minW*cos(finalTheta) + clusterMean.y;
common/recgeometry/rectangleFitter.def.h:206:56:   rectCoordinates[3].x = minL*cos(finalTheta) - maxW*sin(finalTheta) + clusterMean.x;
common/recgeometry/rectangleFitter.def.h:207:33:   rectCoordinates[3].y = minL*sin(finalTheta) + maxW*cos(finalTheta) + clusterMean.y;
common/recgeometry/rectangleFitter.def.h:288:23:   double sinAngle = sin(angle);
common/recgeometry/rectangleFitter.def.h:463:27:   double sinAngle = sin(angle);
common/recgeometry/recPolygon2D.cpp:674:14:   st = sin(theta);
common/recgeometry/recPolygon2D.cpp:706:10:   st = sin(bestTheta);
common/recgeometry/recTransform2D.cpp:73:8:   sa = sin(pose.rotZ);
common/recgeometry/recTransform2D.cpp:158:13:	double s = sin(double(radAngle));
common/recgeometry/recVector2D.cpp:255:37:   return RecVector2D(cos(radians),sin(radians));
common/recgeometry/recPose3D.cpp:167:10:   sb = sin(rot2);
common/recgeometry/recPose3D.cpp:203:10:   sb = sin(rot2);
common/recgeometry/recPose3D.cpp:239:10:   sb = sin(rot2);
common/recgeometry/recPose3D.cpp:293:8:		sb = sin(rot2);
common/recgeometry/recPose3D.cpp:329:8:		sb = sin(rot2);
common/recgeometry/recPose3D.cpp:366:8:		sb = sin(rot2);
common/recgeometry/basicUnitTest.cc:1029:32:   TargetQuoi.quat[0] = vec.x*sin(phi/2.0); //Book equations agree
common/recgeometry/basicUnitTest.cc:1030:32:   TargetQuoi.quat[1] = vec.y*sin(phi/2.0);
common/recgeometry/basicUnitTest.cc:1031:32:   TargetQuoi.quat[2] = vec.z*sin(phi/2.0);
common/recgeometry/recQuaternion.cpp:246:13:   (*v) *= 1/sin(acos(quat[3]));
common/recgeometry/recQuaternion.cpp:260:8:   v *= sin(phi/2.0);
common/Packetizer/GSOF/gsof_to_txyz.cc:123:20:   vd->Speed * sin(vd->Heading),
common/Packetizer/GSOF/gsof_display.cc:103:68:					snprintf((char *)&buf, 128, "East Vel:   % lfm/s", vd->Speed * sin(vd->Heading));
common/rtrt/Common/Primitives.h:329:9:			if (-sin(heading) * pRelativeToLS[0] + cos(heading) * pRelativeToLS[1] < 0)
common/RoadModelParticle/RoadModelParticle.cc:117:34:   RecVector2D vec(cos(pt.rotZ),sin(pt.rotZ));
common/RoadModelParticle/RoadModelParticle.cc:345:42:   RecVector2D vec(cos((*itr).rotZ),sin((*itr).rotZ));
common/DatumShifter/DatumShifter.def.h:5:41:   METERS N = a / sqrt(1 - e * e * sin(lat) * sin(lat));
common/DatumShifter/DatumShifter.def.h:8:36:   y = (N + alt) * cos(lat) * sin(lon);
common/DatumShifter/DatumShifter.def.h:9:45:   z = ((b / a) * (b / a) * N + alt) * sin(lat);
common/DatumShifter/DatumShifter.def.h:17:52:   lat = atan2((z + eprime * eprime * b * pow(sin(th), 3)), (p - e * e * a * pow(cos(th), 3)));
common/DatumShifter/DatumShifter.def.h:20:43:   METERS N = a / sqrt(1 - e * e * sin(lat) * sin(lat));
common/DatumShifter/review/20070817/DatumShifter.def.h:5:48:   4 METERS N = a / sqrt(1 - e * e * sin(lat) * sin(lat));
common/DatumShifter/review/20070817/DatumShifter.def.h:8:43:   6 y = (N + alt) * cos(lat) * sin(lon);
common/DatumShifter/review/20070817/DatumShifter.def.h:9:52:   7 z = ((b / a) * (b / a) * N + alt) * sin(lat);
common/DatumShifter/review/20070817/DatumShifter.def.h:17:59:   13 lat = atan2((z + eprime * eprime * b * pow(sin(th), 3)), (p - e * e * a * pow(cos(th), 3)));
common/DatumShifter/review/20070817/DatumShifter.def.h:20:50:   15 METERS N = a / sqrt(1 - e * e * sin(lat) * sin(lat));
common/MovingObstacle/MovingObstacle.cc:729:44:   RecVector2D heading(cos(poseV[0].rotZ),sin(poseV[0].rotZ));
common/MovingObstacle/MovingObstacle.cc:802:42:   RecVector2D heading(cos(poseV[0].rotZ),sin(poseV[0].rotZ));
common/MovingObstacle/review/20070715/MovingObstacle.cc:545:51:   465 RecVector2D heading(cos(poseV[0].rotZ),sin(poseV[0].rotZ));
common/MovingObstacle/review/20070715/MovingObstacle.cc:618:49:   528 RecVector2D heading(cos(poseV[0].rotZ),sin(poseV[0].rotZ));
common/MovingTarget/review/20070715/MovingTarget.cc:73:30:   62 double s1=sin(angle1)*minor;
common/MovingTarget/review/20070715/MovingTarget.cc:75:30:   64 double s2=sin(angle2)*minor;
common/MovingTarget/MovingTarget.cc:82:23:   double s1=sin(angle1)*minor;
common/MovingTarget/MovingTarget.cc:84:23:   double s2=sin(angle2)*minor;
planning/Planner3D/planner3D.cpp:924:20:   double sinth = sin(pose.theta);
planning/Planner3D/planner3D.cpp:978:20:   double sinth = sin(pose->theta);
planning/Planner3D/planner3D.cpp:1097:20:   double sinth = sin(pose->theta);
planning/Planner3D/planner3D.cpp:1389:67:								endPose.y = initialPose.y + actionDynamics->action.tv*dur*sin(initialPose.theta);
planning/Planner3D/planner3D.cpp:1442:19:								tvoverrv*(sin(actionDynamics->action.rv*ts+initialPose.theta)-sin(initialPose.theta));
planning/Planner3D/planner3D.cpp:1450:60:							newy = initialPose.y + actionDynamics->action.tv*ts*sin(initialPose.theta);
planning/Planner3D/Planner3DTaskUpdateFunctions.cc:463:79:   mapPoint.y += translationToLeftForDynamicObstacleHighCostRegions_m_ * sin(perpendicularTheta);
planning/Planner3D/Planner3DTaskUpdateFunctions.cc:1006:95:   //robotPose.y = robotPose.y + currentVehicleState_.speed_mps*(float)PLANNING_TIME_SEC/2.0*sin(robotPose.theta);
planning/Planner3D/utils.cpp:125:54:   double newx = pose1->x*cos(angle_rad) - pose1->y*sin(angle_rad);
planning/Planner3D/utils.cpp:126:28:   double newy = pose1->x*sin(angle_rad) + pose1->y*cos(angle_rad);
planning/Planner3D/SearchSpace2D.cpp:2149:23:   double sinAngle = sin((double)worldPose.rotZ);
planning/Planner3D/SearchSpace2D.cpp:2386:33:   //startPose.y = startPose.y - sin(startPose.theta)*REAR_AXLE_TO_CENTER_M;
planning/Planner3D/SearchSpace2D.cpp:2733:79:   int rear_axle_y = searchPose->y - (int)((REAR_AXLE_TO_CENTER/cellSize_m_)*sin((float)searchPose->theta*2.0*M_PI/(float)NUMOFANGLEVALS));
planning/LocalPlanner/DynamicObstacleChecker.cpp:290:18:   double sinth = sin(pose->rotZ);
planning/LocalPlanner/DynamicObstacleChecker.cpp:470:39:   RecVector2D heading(cos(poseV.rotZ),sin(poseV.rotZ));
planning/LocalPlanner/UTurnPlanner.cpp:70:67:   double distanceAlongNormal = fabs(vectorToInitialState.length()*sin((double)angleToInitialState));
planning/LocalPlanner/UTurnPlanner.cpp:95:258:   printf("Computed arc length is %lf and arc heading change is %lf (final arc length after front of vehicle subtraction is %lf) lane width is %lf conservative turning radius %lf\n", arcLength_m, arcTheta, arcLength_m - REAR_AXLE_TO_FRONT_WHEELS_LENGTH*sin(arcTheta), laneWidth_m_, CONSERVATIVE_TURNING_RADIUS_M);
planning/LocalPlanner/UTurnPlanner.cpp:105:55:   arcLength_m -= REAR_AXLE_TO_FRONT_WHEELS_LENGTH*sin(arcTheta);
planning/LocalPlanner/UTurnPlanner.cpp:198:89:   double currentLengthPerpendicularToLane_m = fabs(REAR_AXLE_TO_FRONT_WHEELS_LENGTH*sin(relativeInitialState.yaw - initialState.yaw));
planning/LocalPlanner/review/20070830/DynamicObstacleChecker.cpp:244:25:   205 double sinth = sin(pose->rotZ);
planning/LocalPlanner/review/20070830/DynamicObstacleChecker.cpp:424:46:   356 RecVector2D heading(cos(poseV.rotZ),sin(poseV.rotZ));
planning/LocalPlanner/review/20070830/UTurnPlanner.cpp:70:74:   60 double distanceAlongNormal = fabs(vectorToInitialState.length()*sin((double)angleToInitialState));
planning/LocalPlanner/review/20070830/UTurnPlanner.cpp:95:224:   84 printf("Computed arc length is %lf and arc heading change is %lf (final arc length after front of vehicle subtraction is %lf\n", arcLength_m, arcTheta, arcLength_m - REAR_AXLE_TO_INSIDE_OF_FRONT_BUMPER_LENGTH*sin(arcTheta));
planning/LocalPlanner/review/20070830/UTurnPlanner.cpp:105:72:   94 arcLength_m -= REAR_AXLE_TO_INSIDE_OF_FRONT_BUMPER_LENGTH*sin(arcTheta);
planning/LocalPlanner/review/20070830/SimpleTahoeVehicleModel.cpp:221:51:   190		next_state->y = current_state->y + v_dt * sin( current_state->yaw );		// determine the change in y
planning/LocalPlanner/review/20070830/ugc_initial_guess_table.cpp:219:143:   191 terminal_local_state.x = (terminal_state.x - initial_state.x) * cos(-(initial_state.yaw)) - (terminal_state.y - initial_state.y) * sin(-(initial_state.yaw));
planning/LocalPlanner/review/20070830/ugc_initial_guess_table.cpp:220:76:   192 terminal_local_state.y = (terminal_state.x - initial_state.x) * sin(-(initial_state.yaw)) + (terminal_state.y - initial_state.y) * cos(-(initial_state.yaw));
planning/LocalPlanner/review/20070830/LocalPlanner.cpp:1286:87:   1168 RecPoint2D currentHeadingVector(cos(nextVehicleState.yaw), sin(nextVehicleState.yaw));
planning/LocalPlanner/review/20070830/LocalPlanner.cpp:1461:68:   1339 double perpendicularDistance = distanceToDesiredState * sin((double)worldRelativeAngleToDesiredPoint);
planning/LocalPlanner/review/20070830/LocalPlanner.cpp:1480:76:   1356 RecPoint2D currentHeadingVector(cos(lookaheadVehicleState.yaw), sin(lookaheadVehicleState.yaw));
planning/LocalPlanner/review/20070830/LocalPlanner.cpp:1635:80:   1501 RecPoint2D initialHeadingVector(cos(lookaheadVehicleState.yaw), sin(lookaheadVehicleState.yaw));
planning/LocalPlanner/review/20070830/LocalPlanner.cpp:1821:71:   1679 desiredVehicleState.y += LARGE_SLOWING_DOWN_DISTANCE_M*sin(desiredVehicleState.yaw);
planning/LocalPlanner/review/20070830/LocalPlanner.cpp:1824:71:   1682 desiredVehicleState.y -= LARGE_SLOWING_DOWN_DISTANCE_M*sin(desiredVehicleState.yaw);
planning/LocalPlanner/review/20070830/LocalPlanner.cpp:1872:78:   1729 RecPoint2D currentHeadingVector(cos(currentVehicleState.yaw), sin(currentVehicleState.yaw));
planning/LocalPlanner/review/20070830/LocalPlanner.cpp:2129:68:   1979 desiredVehicleState.y -= BACKUP_DISTANCE_WHEN_STUCK*sin(desiredVehicleState.yaw);
planning/LocalPlanner/review/20070830/LocalPlanner.cpp:2707:71:   2532 RecPoint2D currentHeadingVector(cos(nextVehicleState.yaw), sin(nextVehicleState.yaw));
planning/LocalPlanner/review/20070830/LocalPlanner.cpp:2805:79:   2621 RecPoint2D currentHeadingVector(cos(nextVehicleState.yaw), sin(nextVehicleState.yaw));
planning/LocalPlanner/review/20070830/LocalPlanner.cpp:3046:94:   2843 desiredVehicleState.y = pathPoint.y - (double)laneRelativeToPath*laneWidth_m_*sin(pathPoint.yaw + LP_PI_OVER_2);
planning/LocalPlanner/review/20070830/LocalPlanner.cpp:3059:171:   2856 desiredVehicleState.y = pathPoint.y + ((double)perpendicularOffset/(double)numPointsToPlanPerpendicularToPath)*planningMaxPerpendicularDistanceFromPath_ * sin(pathPoint.yaw + LP_PI_OVER_2);
planning/LocalPlanner/review/20070830/intersectRectangles.cpp:23:23:   20 sina = sin(ang);
planning/LocalPlanner/review/20070830/intersectRectangles.cpp:36:23:   31 sina = sin(ang); // - values for repeated use
planning/LocalPlanner/review/20070830/StrippedDownLocalPlannerTask.cc:246:48:   210 desiredVehicleState.y += 10.0*sin(desiredVehicleState.yaw);
planning/LocalPlanner/review/20070830/StrippedDownLocalPlannerTask.cc:249:47:   213 desiredVehicleState.x += 1.0*sin(desiredVehicleState.yaw);
planning/LocalPlanner/review/20070830/StrippedDownLocalPlannerTask.cc:261:48:   223 desiredVehicleState.y -= 10.0*sin(desiredVehicleState.yaw);
planning/LocalPlanner/review/20070830/StrippedDownLocalPlannerTask.cc:264:47:   225 desiredVehicleState.x += 1.0*sin(desiredVehicleState.yaw);
planning/LocalPlanner/review/20070830/LocalPlannerTask-functions.cc:299:31:   260 double sinth = sin(currentVehicleState_.yaw);
planning/LocalPlanner/review/20070830/LocalPlannerTask-functions.cc:710:43:   648 double sinth = sin(closestPoseInLane.rotZ);
planning/LocalPlanner/review/20070830/LocalPlannerTask-functions.cc:831:75:   760 leftSideLanePoint.y = currentLanePoint.y - 1.0*sin(currentVehicleState_.yaw + LP_PI_OVER_2);
planning/LocalPlanner/review/20070830/LocalPlannerTask-functions.cc:3178:98:   2980 globalGoal3DPosition.y = globalGoal3DPosition.y + ZONE_POSE_GOAL_GPS_BUFFER_M*sin((double)globalGoal3DPosition.rotZ);
planning/LocalPlanner/review/20070830/LocalPlannerTask-functions.cc:3248:44:   3045 sinth = sin(newTheta);
planning/LocalPlanner/review/20070830/LocalPlannerTask-functions.cc:3496:73:   3285 uTurnGoalState_->y = newGoal.goalPose.y + 12.0*sin(newGoal.goalPose.rotZ);
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:216:61:   193 frontBumperState.x -= (VEHICLEWIDTH_M/2)*sin(frontBumperState.yaw);
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:222:61:   199 frontBumperState.x += (VEHICLEWIDTH_M/2)*sin(frontBumperState.yaw);
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:392:67:   362 frontBumperState.x -= (VEHICLEWIDTH_M/2)*sin(frontBumperState.yaw);
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:398:67:   368 frontBumperState.x += (VEHICLEWIDTH_M/2)*sin(frontBumperState.yaw);
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:498:25:   459 double sinth = sin(vState->yaw);
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:721:25:   660 double sinth = sin(vState->yaw);
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:726:127:   664 tahoeShape.corner[FL].x = vState->x + (REAR_AXLE_TO_FRONT_BUMPER_LENGTH)*costh - (VEHICLEWIDTH_M/2)*sinth; // using -sin(yaw) as it is equivalent to +cos(yaw+90)
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:727:158:   665 tahoeShape.corner[FL].y = vState->y + (REAR_AXLE_TO_FRONT_BUMPER_LENGTH)*sinth + (VEHICLEWIDTH_M/2)*costh; // using cos(yaw) as it is equivalent to sin(yaw+90)
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:746:25:   680 double sinth = sin(vState->yaw);
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:751:159:   684 tahoeShape.corner[FL].x = vState->x + (REAR_AXLE_TO_FRONT_BUMPER_LENGTH + extraBuffer_m)*costh - (VEHICLEWIDTH_M/2 + extraBuffer_m)*sinth; // using -sin(yaw) as it is equivalent to +cos(yaw+90)
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:752:190:   685 tahoeShape.corner[FL].y = vState->y + (REAR_AXLE_TO_FRONT_BUMPER_LENGTH + extraBuffer_m)*sinth + (VEHICLEWIDTH_M/2 + extraBuffer_m)*costh; // using cos(yaw) as it is equivalent to sin(yaw+90)
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:770:27:   700 double sinth = sin(vState->yaw);
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:775:139:   705 tahoeShape.corner[FL].x = vState->x + (OUTER_REAR_AXLE_TO_FRONT_BUMPER_LENGTH)*costh - (OUTER_VEHICLEWIDTH/2)*sinth; // using -sin(yaw) as it is equivalent to +cos(yaw+90)
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:776:170:   706 tahoeShape.corner[FL].y = vState->y + (OUTER_REAR_AXLE_TO_FRONT_BUMPER_LENGTH)*sinth + (OUTER_VEHICLEWIDTH/2)*costh; // using cos(yaw) as it is equivalent to sin(yaw+90)
planning/LocalPlanner/SimpleTahoeVehicleModel.cpp:221:44:	next_state->y = current_state->y + v_dt * sin( current_state->yaw );		// determine the change in y
planning/LocalPlanner/ugc_initial_guess_table.cpp:237:136:   terminal_local_state.x = (terminal_state.x - initial_state.x) * cos(-(initial_state.yaw)) - (terminal_state.y - initial_state.y) * sin(-(initial_state.yaw));
planning/LocalPlanner/ugc_initial_guess_table.cpp:238:69:   terminal_local_state.y = (terminal_state.x - initial_state.x) * sin(-(initial_state.yaw)) + (terminal_state.y - initial_state.y) * cos(-(initial_state.yaw));
planning/LocalPlanner/LocalPlanner.cpp:1456:76:   RecPoint2D currentHeadingVector(cos(nextVehicleState.yaw), sin(nextVehicleState.yaw));
planning/LocalPlanner/LocalPlanner.cpp:1659:61:   double perpendicularDistance = distanceToDesiredState * sin((double)worldRelativeAngleToDesiredPoint);
planning/LocalPlanner/LocalPlanner.cpp:1678:69:   RecPoint2D currentHeadingVector(cos(lookaheadVehicleState.yaw), sin(lookaheadVehicleState.yaw));
planning/LocalPlanner/LocalPlanner.cpp:1843:73:   RecPoint2D initialHeadingVector(cos(lookaheadVehicleState.yaw), sin(lookaheadVehicleState.yaw));
planning/LocalPlanner/LocalPlanner.cpp:2037:64:   desiredVehicleState.y += LARGE_SLOWING_DOWN_DISTANCE_M*sin(desiredVehicleState.yaw);
planning/LocalPlanner/LocalPlanner.cpp:2040:64:   desiredVehicleState.y -= LARGE_SLOWING_DOWN_DISTANCE_M*sin(desiredVehicleState.yaw);
planning/LocalPlanner/LocalPlanner.cpp:2088:71:   RecPoint2D currentHeadingVector(cos(currentVehicleState.yaw), sin(currentVehicleState.yaw));
planning/LocalPlanner/LocalPlanner.cpp:2358:65:   desiredVehicleState.y -= BACKUP_DISTANCE_WHEN_STUCK*sin(desiredVehicleState.yaw);
planning/LocalPlanner/LocalPlanner.cpp:2441:73:   pathOffsetVehicleState.y += pathOffsetForDefensiveDrivingInZones_m_*sin(M_PI/2.0 + pathOffsetVehicleState.yaw);
planning/LocalPlanner/LocalPlanner.cpp:3143:87:   desiredVehicleState.y = pathPoint.y - (double)laneRelativeToPath*laneWidth_m_*sin(pathPoint.yaw + LP_PI_OVER_2);
planning/LocalPlanner/LocalPlanner.cpp:3156:164:   desiredVehicleState.y = pathPoint.y + ((double)perpendicularOffset/(double)numPointsToPlanPerpendicularToPath)*planningMaxPerpendicularDistanceFromPath_ * sin(pathPoint.yaw + LP_PI_OVER_2);
planning/LocalPlanner/intersectRectangles.cpp:23:16:   sina = sin(ang);
planning/LocalPlanner/intersectRectangles.cpp:36:16:   sina = sin(ang); // - values for repeated use
planning/LocalPlanner/StrippedDownLocalPlannerTask.cc:246:41:   desiredVehicleState.y += 10.0*sin(desiredVehicleState.yaw);
planning/LocalPlanner/StrippedDownLocalPlannerTask.cc:249:40:   desiredVehicleState.x += 1.0*sin(desiredVehicleState.yaw);
planning/LocalPlanner/StrippedDownLocalPlannerTask.cc:261:41:   desiredVehicleState.y -= 10.0*sin(desiredVehicleState.yaw);
planning/LocalPlanner/StrippedDownLocalPlannerTask.cc:264:40:   desiredVehicleState.x += 1.0*sin(desiredVehicleState.yaw);
planning/LocalPlanner/LocalPlannerTask-functions.cc:359:24:   double sinth = sin(currentVehicleState_.yaw);
planning/LocalPlanner/LocalPlannerTask-functions.cc:800:36:   double sinth = sin(closestPoseInLane.rotZ);
planning/LocalPlanner/LocalPlannerTask-functions.cc:929:80:   leftSideLanePoint.y = currentLanePoint.y - 1.0*sin(currentVehicleState_.yaw + LP_PI_OVER_2);
planning/LocalPlanner/LocalPlannerTask-functions.cc:1975:225:   //logger_.log_info("updating path point %d from %Lf %Lf v %Lf to %Lf %Lf v %lf\n", i, vehicleState->x, vehicleState->y, vehicleState->v, vehicleState->x + cos(vehicleState->yaw)*currentLaneWidth, vehicleState->y + sin(vehicleState->yaw)*currentLaneWidth, 0.0);
planning/LocalPlanner/LocalPlannerTask-functions.cc:1978:45:   vehicleState->y = vehicleState->y + sin(vehicleState->yaw + M_PI/2)*currentLaneWidth;
planning/LocalPlanner/LocalPlannerTask-functions.cc:3407:20:   double sinth = sin(theta);
planning/LocalPlanner/LocalPlannerTask-functions.cc:3981:99:   globalGoal3DPosition.y = globalGoal3DPosition.y + ZONE_POSE_GOAL_GPS_BUFFER_M*sin((double)globalGoal3DPosition.rotZ);
planning/LocalPlanner/LocalPlannerTask-functions.cc:4047:37:   sinth = sin(newTheta);
planning/LocalPlanner/LocalPlannerTask-functions.cc:4285:60:   lanePoint.y -= VEHICLELENGTH_M/2.0*sin(lanePoint.rotZ);
planning/LocalPlanner/LocalPlannerTask-functions.cc:4304:94:   newGoalWithCost.pose.y = lanePoint.y + lateralOffset*lateralSign*sin((double)lanePoint.rotZ + M_PI/2);
planning/LocalPlanner/LocalPlannerTask-functions.cc:4343:66:   yDiff = VEHICLELENGTH_M/2.0*(sin(lanePoint.rotZ) - sin(newGoalWithCost.pose.rotZ));
planning/LocalPlanner/LocalPlannerTask-functions.cc:4355:66:   yDiff = VEHICLELENGTH_M/2.0*(sin(lanePoint.rotZ) - sin(newGoalWithCost.pose.rotZ));
planning/LocalPlanner/LocalPlannerTask-functions.cc:4379:103:   newGoalWithCost.pose.y = globalGoal3DPosition.y + longitudinalOffset*sign*sin((double)globalGoal3DPosition.rotZ) + lateralOffset*lateralSign*sin((double)globalGoal3DPosition.rotZ + M_PI/2);
planning/LocalPlanner/LocalPlannerTask-functions.cc:4390:94:   frontBumper.y = newGoalWithCost.pose.y + VEHICLELENGTH_M/2.0*sin((double)newGoalWithCost.pose.rotZ);
planning/LocalPlanner/LocalPlannerTask-functions.cc:4392:93:   rearBumper.y = newGoalWithCost.pose.y - VEHICLELENGTH_M/2.0*sin((double)newGoalWithCost.pose.rotZ);
planning/LocalPlanner/LocalPlannerTask-functions.cc:4439:70:   yDiff = VEHICLELENGTH_M/2.0*(sin(globalGoal3DPosition.rotZ) - sin(newGoalWithCost.pose.rotZ));
planning/LocalPlanner/LocalPlannerTask-functions.cc:4455:70:   yDiff = VEHICLELENGTH_M/2.0*(sin(globalGoal3DPosition.rotZ) - sin(newGoalWithCost.pose.rotZ));
planning/LocalPlanner/LocalPlannerTask-functions.cc:4493:28:   double sinth = sin((double)currentPose.rotZ);
planning/LocalPlanner/LocalPlannerTask-functions.cc:4742:66:   uTurnGoalState_->y = newGoal.goalPose.y + 12.0*sin(newGoal.goalPose.rotZ);
planning/LocalPlanner/CollisionChecker.cpp:258:54:   frontBumperState.x -= (VEHICLEWIDTH_M/2)*sin(frontBumperState.yaw);
planning/LocalPlanner/CollisionChecker.cpp:264:54:   frontBumperState.x += (VEHICLEWIDTH_M/2)*sin(frontBumperState.yaw);
planning/LocalPlanner/CollisionChecker.cpp:425:60:   frontBumperState.x -= (VEHICLEWIDTH_M/2)*sin(frontBumperState.yaw);
planning/LocalPlanner/CollisionChecker.cpp:431:60:   frontBumperState.x += (VEHICLEWIDTH_M/2)*sin(frontBumperState.yaw);
planning/LocalPlanner/CollisionChecker.cpp:524:18:   double sinth = sin(vState->yaw);
planning/LocalPlanner/CollisionChecker.cpp:592:18:   double sinth = sin(vState->yaw);
planning/LocalPlanner/CollisionChecker.cpp:874:18:   double sinth = sin(vState->yaw);
planning/LocalPlanner/CollisionChecker.cpp:879:144:   tahoeShape.corner[FL].x = vState->x + (HARD_BUFFER_REAR_AXLE_TO_FRONT_BUMPER_LENGTH)*costh - (HARD_BUFFER_VEHICLEWIDTH_M/2)*sinth; // using -sin(yaw) as it is equivalent to +cos(yaw+90)
planning/LocalPlanner/CollisionChecker.cpp:880:175:   tahoeShape.corner[FL].y = vState->y + (HARD_BUFFER_REAR_AXLE_TO_FRONT_BUMPER_LENGTH)*sinth + (HARD_BUFFER_VEHICLEWIDTH_M/2)*costh; // using cos(yaw) as it is equivalent to sin(yaw+90)
planning/LocalPlanner/CollisionChecker.cpp:900:18:   double sinth = sin(vState->yaw);
planning/LocalPlanner/CollisionChecker.cpp:905:156:   tahoeShape.corner[FL].x = vState->x + (OUTER_HARD_BUFFER_REAR_AXLE_TO_FRONT_BUMPER_LENGTH)*costh - (OUTER_HARD_BUFFER_VEHICLEWIDTH_M/2)*sinth; // using -sin(yaw) as it is equivalent to +cos(yaw+90)
planning/LocalPlanner/CollisionChecker.cpp:906:187:   tahoeShape.corner[FL].y = vState->y + (OUTER_HARD_BUFFER_REAR_AXLE_TO_FRONT_BUMPER_LENGTH)*sinth + (OUTER_HARD_BUFFER_VEHICLEWIDTH_M/2)*costh; // using cos(yaw) as it is equivalent to sin(yaw+90)
planning/LocalPlanner/CollisionChecker.cpp:926:18:   double sinth = sin(vState->yaw);
planning/LocalPlanner/CollisionChecker.cpp:936:152:   tahoeShape.corner[FL].x = vState->x + (REAR_AXLE_TO_FRONT_BUMPER_LENGTH + extraBuffer_m)*costh - (VEHICLEWIDTH_M/2 + extraBuffer_m)*sinth; // using -sin(yaw) as it is equivalent to +cos(yaw+90)
planning/LocalPlanner/CollisionChecker.cpp:937:183:   tahoeShape.corner[FL].y = vState->y + (REAR_AXLE_TO_FRONT_BUMPER_LENGTH + extraBuffer_m)*sinth + (VEHICLEWIDTH_M/2 + extraBuffer_m)*costh; // using cos(yaw) as it is equivalent to sin(yaw+90)
planning/LocalPlanner/CollisionChecker.cpp:955:20:   double sinth = sin(vState->yaw);
planning/LocalPlanner/CollisionChecker.cpp:960:132:   tahoeShape.corner[FL].x = vState->x + (OUTER_REAR_AXLE_TO_FRONT_BUMPER_LENGTH)*costh - (OUTER_VEHICLEWIDTH/2)*sinth; // using -sin(yaw) as it is equivalent to +cos(yaw+90)
planning/LocalPlanner/CollisionChecker.cpp:961:163:   tahoeShape.corner[FL].y = vState->y + (OUTER_REAR_AXLE_TO_FRONT_BUMPER_LENGTH)*sinth + (OUTER_VEHICLEWIDTH/2)*costh; // using cos(yaw) as it is equivalent to sin(yaw+90)
infrastructure/trocs/widgets/LidarViewer.cc:114:26:   const double x = cos(lastScan_[i].azimuth_rad + M_PI / 2) * lastScan_[i].range_m;
infrastructure/trocs/widgets/MissionPlanningTool.cc:1260:32:   glVertex3d(1.5*cos(degrees*0.0174532925)+2, 1.5*sin(degrees*0.0174532925)+2, 0-1);
infrastructure/trocs/widgets/DriveCommandDisplay.cc:116:33:   glVertex2d(radius - cos(i / 180.0 * M_PI) * radius, sin(i / 180.0 * M_PI) * fabs(radius));
infrastructure/trocs/widgets/LidarDisplay3D.cc:76:29:   laserPt.x = cos(ls[jj].azimuth_rad)*ls[jj].range_m * cos(ls[jj].elevation_rad);
infrastructure/trocs/widgets/LidarDisplay3D.cc:77:70:   laserPt.y = sin(ls[jj].azimuth_rad)*ls[jj].range_m * cos(ls[jj].elevation_rad);
infrastructure/trocs/widgets/RoadBlockageDisplay.cc:277:34:   glVertex2d( radius * cos((float)ii / (float)npoints * (2 * M_PI)),
infrastructure/trocs/widgets/RoadBlockageDisplay.cc:285:30:   glVertex2f( radius * cos(0), radius * sin(0) );
infrastructure/trocs/widgets/RoadBlockageDisplay.cc:286:30:   glVertex2f( radius * cos(M_PI), radius * sin(M_PI) );
infrastructure/trocs/widgets/VelodyneByLaserDrawable.cc:80:25:   laserPt.x = cos(mm->azimuth_rad)*mm->range_m * cos(mm->elevation_rad);
infrastructure/trocs/widgets/VelodyneByLaserDrawable.cc:81:60:   laserPt.y = sin(mm->azimuth_rad)*mm->range_m * cos(mm->elevation_rad);
infrastructure/trocs/widgets/VehStateDisplay.cc:531:46:   glVertex2d(pos.x+cos(rr)*distance, pos.y+sin(rr)*distance);
infrastructure/trocs/widgets/VehStateDisplay.cc:621:25:   RecVector2D dir(cos(centerPose.rot1),sin(centerPose.rot1));
infrastructure/trocs/widgets/PointCloudViewer.cc:616:25:   laserPt.x = cos(ls[jj].azimuth_rad)*ls[jj].range_m;
infrastructure/trocs/widgets/PointCloudViewer.cc:873:25:   laserPt.x = cos(ls[jj].azimuth_rad)*ls[jj].range_m;
infrastructure/trocs/widgets/PointCloudViewer.cc:2143:52:   eyevector.x=camzoom[screenNumber]*sin(camphi_)*cos(camtheta_);
infrastructure/trocs/widgets/PointCloudViewer.cc:2145:39:   eyevector.z=camzoom[screenNumber]*cos(camphi_);
infrastructure/trocs/widgets/LidarCalib/LidarCalib.cc:145:16:   pt.x = cos(r.azimuth_rad)*r.range_m * cos(r.elevation_rad);
infrastructure/trocs/widgets/LidarCalib/LidarCalib.cc:146:47:   pt.y = sin(r.azimuth_rad)*r.range_m * cos(r.elevation_rad);
infrastructure/trocs/widgets/MotionCommandsDisplay.cc:334:25:   heading.x = scale * cos(goal.rotZ);
infrastructure/trocs/widgets/StandardLayerCamera.cc:125:21:   dY /= cos(cameraElevation_ * 3.14159/180.0);
infrastructure/trocs/widgets/StandardLayerCamera.cc:128:34:   cameraOffset_.y += cos(cameraOffset_.rotZ) * dY;
infrastructure/trocs/widgets/StandardLayerCamera.cc:130:34:   cameraOffset_.x += cos(cameraOffset_.rotZ) * dX;
infrastructure/trocs/widgets/UtilityLayers.cc:222:29:   double xx = cos(2.0 * PI * colorPerFacet * (double) ii);
infrastructure/trocs/widgets/SafeTracDisplay.cc:98:33:   offset.x = radius * cos(theta);
infrastructure/trocs/widgets/SafeTracDisplay.cc:177:35:   offsetPt.x = radius * cos(theta);
infrastructure/trocs/widgets/DrawRoad.cc:60:20:   RecPoint2D dir(cos(pose.rotZ),sin(pose.rotZ));
infrastructure/trocs/widgets/DrawRoad.cc:82:20:   RecPoint2D dir(cos(pose.rotZ),sin(pose.rotZ));
infrastructure/trocs/widgets/DrawRoad.cc:700:18:   laneOffset.y=cos(rotZ)*(0.5+5.0*numLanes);
infrastructure/trocs/widgets/DrawRoad.cc:718:11:   dir.x=cos(pose.rotZ);
infrastructure/trocs/widgets/DrawRoad.cc:844:21:   RecVector2D dir(cos(pose.rotZ),sin(pose.rotZ));
infrastructure/trocs/widgets/DrawRoad.cc:992:30:   glVertex3d(scale*cos(degrees*dToR_)+p.x-renderOffset.x, scale*sin(degrees*dToR_)+p.y-renderOffset.y, 0-renderOffset.z);
infrastructure/trocs/widgets/DrawRoad.cc:1026:30:   glVertex3d(scale*cos(degrees*dToR_)+p.x-renderOffset.x, scale*sin(degrees*dToR_)+p.y-renderOffset.y, 0-renderOffset.z);
interfaces/PointSource/Input/PointedLineScanner/Impl.cc:113:50:   sensorPoint.x = lr.range_m * cos( lr.azimuth_rad );
perception/LaneMarkerDetectorAux/LaneMarkerDetectorAuxCG.cc:332:31:   double cosTheta = cos( lines[ ln ].theta );
perception/LaneMarkerDetectorAux/LaneMarkerDetectorAuxWZ.cc:270:46:   projectionDist = ptIter->x * cos(curLine.theta) + ptIter->y * sin(curLine.theta) - curLine.rho;
perception/LaneMarkerDetectorAux/LaneMarkerDetectorAuxWZ.cc:337:56:   int EdgeOffsetX = (int) round(filterScaleDist_*cos(angle));
perception/LaneMarkerDetectorAux/LaneMarkerDetectorAuxWZ.cc:479:35:   double cosTheta = cos(curLine.theta);
perception/LaneMarkerDetectorAux/LaneMarkerDetectorAuxWZ.cc:481:37:   double cosTheta90 = cos(curLine.theta-PI/2);
perception/ApplanixTask/ApplanixTask.cc:727:35:   return group1->VehicleSpeed * cos((group1->VehicleTrackAngle - group1->VehicleHeading) * DEG_TO_RAD);
perception/ApplanixTask/review/20070806/ApplanixTask.cc:452:60:   367 * cos((group1->VehicleTrackAngle - group1->VehicleHeading)
perception/HoughRoads/hough.cpp:49:35:   curRho = xVals[ptI] * cos(curTheta) + yVals[ptI] * sin(curTheta);
perception/HoughRoads/hough.cpp:89:39:   curRho = xVals[ptI] * cos(curTheta) + yVals[ptI] * sin(curTheta) + widths[widthI];
perception/HoughRoads/hough.cpp:433:29:   curR = xVals[ptA] * cos(curTheta) + yVals[ptA] * sin(curTheta) - curWidth / 2;
perception/VisibilityMap/VisibilityMapBuilder.cc:444:76:   xx = vehiclePose2D.x + visibilityMapVelodyneReliableRange_m_ * cos(increment);
perception/VisibilityMap/review/20070827/VisibilityMapBuilder.cc:387:87:   307 xx = vehiclePose2D.x + visibilityMapVelodyneReliableRange_m_ * cos(increment);
perception/OcclusionHypothesizer/OcclusionHypothesizer.cc:320:41:   RecDifferentialPose2D(cos(pose.rotZ) * speed_mps, sin(pose.rotZ) * speed_mps, 0),
perception/OcclusionHypothesizer/OcclusionHypothesizer.cc:341:21:   RecVector2D dir(cos(pose.rotZ), sin(pose.rotZ));
perception/LaneMarkerDetector/LaneMarkerDetector.cc:453:56:   int EdgeOffsetX = (int) round(filterScaleDist_*cos(angle));
perception/LaneMarkerDetector/LaneMarkerDetector.cc:567:35:   double cosTheta = cos(curLine.theta);
perception/LaneMarkerDetector/LaneMarkerDetector.cc:569:37:   double cosTheta90 = cos(curLine.theta-PI/2);
perception/AlignTool/AlignTool.cc:320:30:   deltaAngle_=acos(scalPord/s);
perception/VelodyneSegmenter/testQuickTrig.cc:13:28:   cout << QuickTrig::cos( ii * M_PI/180 ) << " "
perception/VelodyneSegmenter/quickTrig.h:22:25:   static inline float cos(float x) { return cosLookup_[(unsigned int) ( ( x + 4 * M_PI ) * convertFactor_)]; };
perception/VelodyneSegmenter/CarClassifier.cc:175:23:   double cosTheta = cos(thetaLong);
perception/VelodyneSegmenter/VelodyneSegmenter.cc:589:42:   segPt.localPt.x = QuickTrig::cos(ls[idx].azimuth_rad)*ls[idx].range_m * QuickTrig::cos(ls[idx].elevation_rad);
perception/VelodyneSegmenter/VelodyneSegmenter.cc:590:96:   segPt.localPt.y = QuickTrig::sin(ls[idx].azimuth_rad)*ls[idx].range_m * QuickTrig::cos(ls[idx].elevation_rad);
perception/VelodyneViewer/int_calibrate.cpp:129:13:   // [r*cos(theta), r*sin(theta), r, 1.0, r, theta, cos(theta), sin(theta)]
perception/VelodyneViewer/int_calibrate.cpp:141:57:   data[ 8 * _M + 0 ] = r * ( data[ 8 * _M + 6 ] = cos( theta ) );
perception/VelodyneViewer/int_calibrate.cpp:290:13:   // [r*cos(theta), r*sin(theta), r, 1.0, r, theta, cos(theta), sin(theta)]
perception/VelodyneViewer/int_calibrate.cpp:303:27:   double costheta = cos( theta );
perception/VelodyneViewer/int_calibrate.cpp:514:39:   data[ 0 ] = r * ( data[ 6 ] = cos( theta ) );
perception/VelodyneViewer/int_calibrate.cpp:545:27:   // data[ 0 ] = r cos(theta)
perception/VelodyneViewer/int_calibrate.cpp:551:25:   // data[ 6 ] = cos(theta)
perception/VelodyneViewer/int_calibrate.cpp:556:55:   data[ 8 * n + 0 ] = r * ( data[ 8 * n + 6 ] = cos( theta ) );
perception/VelodyneViewer/int_calibrate.cpp:980:36:   double cosElevation = cos( elevation );
perception/VelodyneViewer/int_calibrate.cpp:996:64:   a * r * cosElevation * cos( azimuthOffset + theta ) +
perception/VelodyneViewer/int_calibrate.cpp:1283:36:   double cosElevation = cos( elevation );
perception/VelodyneViewer/int_calibrate.cpp:1302:70:   a1 * r * cosElevation * cos( azimuthOffset + theta ) +
perception/VelodyneViewer/int_calibrate.cpp:1311:61:   a2 * r * cosElevation * cos( azimuthOffset + theta ) +
perception/VelodyneViewer/int_calibrate.cpp:1601:28:   double cosElevation = cos( elevation );
perception/VelodyneViewer/int_calibrate.cpp:1610:42:   a * r * cosElevation * cos( azimuthOffset + theta ) +
perception/VelodyneViewer/int_calibrate.cpp:1746:36:   double cosElevation = cos( elevation );
perception/VelodyneViewer/int_calibrate.cpp:1761:51:   double x = r * cosElevation * cos( theta - azimuthOffset );
perception/VelodyneViewer/int_calibrate.cpp:1768:53:   a1 * r * cosElevation * cos( theta - azimuthOffset ) -
perception/VelodyneViewer/int_calibrate.cpp:1776:53:   a2 * r * cosElevation * cos( theta - azimuthOffset ) -
perception/VelodyneViewer/int_calibrate.cpp:2299:39:   aziOffsetCopyX.push_back( cos( angles[ 2 * i + 0 ] ) );
perception/VelodyneViewer/int_calibrate.cpp:2354:22:   plane[ 0 ] = cos( medianAziOffset ) * a - sin( medianAziOffset ) * b;
perception/VelodyneViewer/int_calibrate.cpp:2355:51:   plane[ 1 ] = sin( medianAziOffset ) * a + cos( medianAziOffset ) * b;
perception/VelodyneViewer/drawableAxis.h:112:16:   z = radius*cos(angle);
perception/VelodyneViewer/drawableAxis.h:126:16:   z = radius*cos(angle);
perception/VelodyneViewer/drawableAxis.h:139:20:   z = 0.5*radius*cos(angle);
perception/VelodyneViewer/drawableAxis.h:153:20:   z = 0.5*radius*cos(angle);
perception/VelodyneViewer/recGeometry/recTransform3D.cpp:171:8:   ca = cos(pose.rot1);
perception/VelodyneViewer/recGeometry/recTransform3D.cpp:172:8:   cb = cos(pose.rot2);
perception/VelodyneViewer/recGeometry/recTransform3D.cpp:173:8:   cg = cos(pose.rot3);
perception/VelodyneViewer/recGeometry/recTransform3D.cpp:480:13:	double c = cos(double(radAngle));
perception/VelodyneViewer/recGeometry/recTransform3D.cpp:503:13:	double c = cos(double(radAngle));
perception/VelodyneViewer/recGeometry/recTransform3D.cpp:526:13:	double c = cos(double(radAngle));
perception/VelodyneViewer/recGeometry/recPolygon2D.cpp:661:10:   ct = cos(theta);
perception/VelodyneViewer/recGeometry/recPolygon2D.cpp:693:8:   ct = cos(bestTheta);
perception/VelodyneViewer/recGeometry/recTransform2D.cpp:63:8:   ca = cos(pose.rotZ);
perception/VelodyneViewer/recGeometry/recTransform2D.cpp:166:13:	double c = cos(double(radAngle));
perception/VelodyneViewer/recGeometry/recPose3D.cpp:127:10:   cb = cos(rot2);
perception/VelodyneViewer/recGeometry/recPose3D.cpp:163:10:   cb = cos(rot2);
perception/VelodyneViewer/recGeometry/recPose3D.cpp:199:10:   cb = cos(rot2);
perception/VelodyneViewer/recGeometry/recPose3D.cpp:217:10:   cb = cos(rot2);
perception/VelodyneViewer/recGeometry/recPose3D.cpp:253:10:   cb = cos(rot2);
perception/VelodyneViewer/recGeometry/recPose3D.cpp:290:8:		cb = cos(rot2);
perception/VelodyneViewer/recGeometry/recQuaternion.cpp:241:18:   (*v) *= 1/sin(acos(quat[3]));
perception/VelodyneViewer/recGeometry/recQuaternion.cpp:243:10:	*phi = acos(quat[3]) * 2;
perception/VelodyneViewer/recGeometry/recQuaternion.cpp:260:13:   quat[3] = cos(phi/2.0);
perception/VelodyneViewer/drawableImage.cpp:134:41:   double r = -a4 / ( a1 * cos( rawTheta ) + a2 * sin( rawTheta ) + a3 );
perception/VelodyneViewer/drawableImage.cpp:173:41:   double r = -a4 / ( a1 * cos( rawTheta ) + a2 * sin( rawTheta ) + a3 );
perception/VelodyneViewer/drawableImage.cpp:1276:21:   phiX += cos( fittedAngles[ i ][ 0 ] );
perception/VelodyneViewer/drawableImage.cpp:1284:21:   phiX += cos( fittedSecondaryAngles[ i ][ 0 ] );
perception/VelodyneViewer/drawableImage.cpp:1490:14:   acos( a1 * a2 + b1 * b2 + c1 * c2 ) );
perception/VelodyneViewer/velodyneInterface/velodyneInterface.cpp:168:25:   X = range * cos( theta ) * cos( phi );
perception/VelodyneViewer/velodyneInterface/velodyneInterface.cpp:169:40:   Y = range * sin( theta ) * cos( phi );
perception/VelodyneViewer/ext_calibrate.cpp:23:17:   double ca = cos( rpy[ 2 ] );
perception/VelodyneViewer/ext_calibrate.cpp:25:17:   double cb = cos( rpy[ 1 ] );
perception/VelodyneViewer/ext_calibrate.cpp:27:17:   double cc = cos( rpy[ 0 ] );
perception/VelodyneViewer/ext_calibrate.cpp:116:18:   theta = acos( 0.5 * ( trace - 1.0 ) );
perception/VelodyneViewer/ext_calibrate.cpp:629:22:// SE2 matrix is { cos(t), sin(t), x }, we just call atan2.
perception/VelodyneViewer/ext_calibrate.cpp:753:17:   double ct = cos( theta ), st = sin( theta );
perception/VelodyneViewer/ext_calibrate.cpp:1627:24:   // x = { tx, ty, cos(theta), sin(theta) }.
perception/VelodyneViewer/ext_calibrate.cpp:1635:24:   relSE2[ 0 ][ 0 ] = cos( theta );
perception/VelodyneViewer/ext_calibrate.cpp:1639:24:   relSE2[ 1 ][ 1 ] = cos( theta );
perception/VelodyneViewer/trackballWindow/drawableAxis.h:121:17:   zz = radius*cos(angle);
perception/VelodyneViewer/trackballWindow/drawableAxis.h:135:17:   zz = radius*cos(angle);
perception/VelodyneViewer/trackballWindow/drawableAxis.h:148:21:   zz = 0.5*radius*cos(angle);
perception/VelodyneViewer/trackballWindow/drawableAxis.h:162:21:   zz = 0.5*radius*cos(angle);
perception/VelodyneViewer/ext_calibrate_gslmm.cpp:27:17:   double ca = cos( rpy[ 2 ] );
perception/VelodyneViewer/ext_calibrate_gslmm.cpp:29:17:   double cb = cos( rpy[ 1 ] );
perception/VelodyneViewer/ext_calibrate_gslmm.cpp:31:17:   double cc = cos( rpy[ 0 ] );
perception/VelodyneViewer/ext_calibrate_gslmm.cpp:51:17:   double ca = cos( rpy[ 2 ] );
perception/VelodyneViewer/ext_calibrate_gslmm.cpp:53:17:   double cb = cos( rpy[ 1 ] );
perception/VelodyneViewer/ext_calibrate_gslmm.cpp:55:17:   double cc = cos( rpy[ 0 ] );
perception/VelodyneViewer/ext_calibrate_gslmm.cpp:144:18:   theta = acos( 0.5 * ( trace - 1.0 ) );
perception/VelodyneViewer/ext_calibrate_gslmm.cpp:227:18:   theta = acos( 0.5 * ( trace - 1.0 ) );
perception/VelodyneViewer/ext_calibrate_gslmm.cpp:740:22:// SE2 matrix is { cos(t), sin(t), x }, we just call atan2.
perception/VelodyneViewer/ext_calibrate_gslmm.cpp:864:17:   double ct = cos( theta ), st = sin( theta );
perception/RoadShapeFuser/RoadShapeFuser.cc:903:32:   tmpPose2D.x += cos(poses.back().rotZ);
perception/RoadShapeFuser/RoadShapeFuser.cc:3494:18:   tmpPose2D.x+=cos(localPose2D.rotZ);
perception/RoadShapeFuser/PFRoadModel.cc:639:16:   c_t += cos((*itr)->phi)*weight;
perception/RoadShapeFuser/PFRoadModel.cc:865:13:   bestX = cos(particles_[indMaxWeight]->phi)* u -
perception/RoadShapeFuser/PFRoadModel.cc:867:13:   bestY = cos(particles_[indMaxWeight]->phi)* v +
perception/RoadShapeFuser/PFRoadModel.cc:889:16:   curX = cos(particles_[idx]->phi)* u -sin(particles_[idx]->phi)*v + particles_[idx]->x;
perception/RoadShapeFuser/PFRoadModel.cc:890:16:   curY = cos(particles_[idx]->phi)* v +sin(particles_[idx]->phi)*u + particles_[idx]->y;
perception/RoadShapeFuser/PFRoadModel.cc:899:24:   c_t += cos(particles_[idx]->phi)*particles_[idx]->weight;
perception/MovingObstacleFuser/DATMOSensor.cc:2100:35:   boundaryPoint[bCounter].x=cos(actAngle);
perception/MovingObstacleFuser/DATMOSensor.cc:2171:30:   if(fabs(dotProd)<cos(DATMO_MAX_DELTA_ANGLE_deg*M_PI/180))
perception/MovingObstacleFuser/DATMOSensor.cc:2399:22:   if(fabs(dotProd)<cos(DATMO_MIN_VIEW_ANGLE_rad))
perception/MovingObstacleFuser/DATMOSensor.cc:2446:26:   if(fabs(dotProd)<cos(DATMO_MIN_VIEW_ANGLE_rad))
perception/MovingObstacleFuser/DATMOSensor.cc:2450:73:   cout << "We should be able to see the side (angle=" << acos(fabs(dotProd))*180.0f/M_PI << ")" << endl;
perception/MovingObstacleFuser/DATMOSensor.cc:3842:33:   //cout << "ANGLE:   " << acos(dotProd)*180.0f/M_PI << endl;
perception/MovingObstacleFuser/DATMOSensor.cc:3844:20:   if(dotProd>cos(DATMO_MAX_EDGE_ASSOC_ANGLE_rad))
perception/MovingObstacleFuser/PointTargetSensor.cc:305:29:   double cos2=pow(cos(sensorDifferentialPose.rotZ),2);
perception/MovingObstacleFuser/MultiSensorMovingObstacleFuser.cc:1923:53:   r->sensorDifferentialPose.x=cos(currentVehicleState.pose.rot1)*currentVehicleState.speed_mps;
perception/MovingObstacleFuser/Filters.cc:365:21:   Fx(sXPOS,sVEL)= cos(x[sYAW])*dt_;
perception/MovingObstacleFuser/Filters.cc:366:26:   Fx(sXPOS,sACC)= 0.5f*cos(x[sYAW])*dt_*dt_;
perception/MovingObstacleFuser/Filters.cc:368:29:   Fx(sYPOS,sYAW)= x[sVEL]*cos(x[sYAW])*dt_ + 0.5f*x[sACC]*cos(x[sYAW])*dt_*dt_;
perception/MovingObstacleFuser/Filters.cc:387:54:   fx_[sXPOS] += (fx_[sVEL] + 0.5f*fx_[sACC]*dt_) * cos(fx_[sYAW])*dt_;
perception/MovingObstacleFuser/Filters.cc:811:42:   zPred_[oXVEL]=x[SimpleBicycle::sVEL]*cos(x[sYAW]);
perception/MovingObstacleFuser/Filters.cc:824:37:   Hx(oXVEL,SimpleBicycle::sVEL )= cos(x[SimpleBicycle::sYAW]);
perception/MovingObstacleFuser/Filters.cc:825:37:   Hx(oYVEL,SimpleBicycle::sYAW )= cos(x[SimpleBicycle::sYAW]);
perception/MovingObstacleFuser/Filters.cc:1064:20:   zPred_[oXPOS]= cos(angleSensor_)*(x[FreePointAcc::sXPOS]-xSensor_)+sin(angleSensor_)*(x[FreePointAcc::sYPOS]-ySensor_);
perception/MovingObstacleFuser/Filters.cc:1065:72:   zPred_[oYPOS]=-sin(angleSensor_)*(x[FreePointAcc::sXPOS]-xSensor_)+cos(angleSensor_)*(x[FreePointAcc::sYPOS]-ySensor_);
perception/MovingObstacleFuser/Filters.cc:1068:14:   +cos(angleSensor_)*(x[FreePointAcc::sXVEL]-vxSensor_+vangleSensor_*(x[FreePointAcc::sYPOS]-ySensor_))
perception/MovingObstacleFuser/Filters.cc:1073:14:   +cos(angleSensor_)*(x[FreePointAcc::sYVEL]-vySensor_-vangleSensor_*(x[FreePointAcc::sXPOS]-xSensor_));
perception/MovingObstacleFuser/Filters.cc:1084:38:   Hx(oXPOS,FreePointAcc::sXPOS) = cos(angleSensor_);
perception/MovingObstacleFuser/Filters.cc:1088:38:   Hx(oYPOS,FreePointAcc::sYPOS) = cos(angleSensor_);
perception/MovingObstacleFuser/Filters.cc:1091:52:   Hx(oXVEL,FreePointAcc::sYPOS) = vangleSensor_*cos(angleSensor_);
perception/MovingObstacleFuser/Filters.cc:1092:38:   Hx(oXVEL,FreePointAcc::sXVEL) = cos(angleSensor_);
perception/MovingObstacleFuser/Filters.cc:1095:52:   Hx(oYVEL,FreePointAcc::sXPOS) = -vangleSensor_*cos(angleSensor_);
perception/MovingObstacleFuser/Filters.cc:1098:38:   Hx(oYVEL,FreePointAcc::sYVEL) = cos(angleSensor_);
perception/MovingObstacleFuser/Filters.cc:1182:12:   xTmp = cos(angleSensor_)*(x[sXPOS]-xSensor_)+sin(angleSensor_)*(x[sYPOS]-ySensor_);
perception/MovingObstacleFuser/Filters.cc:1183:50:   yTmp =-sin(angleSensor_)*(x[sXPOS]-xSensor_)+cos(angleSensor_)*(x[sYPOS]-ySensor_);
perception/MovingObstacleFuser/Filters.cc:1185:31:   double xVelGlobal=x[sVEL]*cos(x[sYAW]);
perception/MovingObstacleFuser/Filters.cc:1194:14:   +cos(angleSensor_)*(xVelGlobal-vxSensor_+vangleSensor_*(x[sYPOS]-ySensor_))
perception/MovingObstacleFuser/Filters.cc:1199:14:   +cos(angleSensor_)*(yVelGlobal-vySensor_-vangleSensor_*(x[sXPOS]-xSensor_));
perception/MovingObstacleFuser/Filters.cc:1206:38:   zPred_[oCORNERXPOS]=xTmp+cos(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f-sin(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1207:79:   zPred_[oCORNERYPOS]=yTmp+sin(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f+cos(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1210:38:   zPred_[oCORNERXPOS]=xTmp+cos(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f+sin(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1211:79:   zPred_[oCORNERYPOS]=yTmp+sin(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f-cos(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1214:38:   zPred_[oCORNERXPOS]=xTmp-cos(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f-sin(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1215:79:   zPred_[oCORNERYPOS]=yTmp-sin(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f+cos(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1218:38:   zPred_[oCORNERXPOS]=xTmp-cos(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f+sin(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1219:79:   zPred_[oCORNERYPOS]=yTmp-sin(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f-cos(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1222:38:   zPred_[oCORNERXPOS]=xTmp+cos(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1226:38:   zPred_[oCORNERXPOS]=xTmp-cos(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1231:38:   zPred_[oCORNERYPOS]=yTmp+cos(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1235:38:   zPred_[oCORNERYPOS]=yTmp-cos(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1264:30:   Hx(oCORNERXPOS,sXPOS) = cos(angleSensor_);
perception/MovingObstacleFuser/Filters.cc:1268:30:   Hx(oCORNERYPOS,sYPOS) = cos(angleSensor_);
perception/MovingObstacleFuser/Filters.cc:1272:38:   Hx(oXVEL,sYPOS) = vangleSensor_*cos(angleSensor_);
perception/MovingObstacleFuser/Filters.cc:1273:24:   Hx(oXVEL,sVEL) = cos(angleSensor_)*cos(x[sYAW])+sin(angleSensor_)*sin(x[sYAW]);
perception/MovingObstacleFuser/Filters.cc:1274:24:   Hx(oXVEL,sYAW) = -cos(angleSensor_)*x[sVEL]*sin(x[sYAW])+sin(angleSensor_)*x[sVEL]*cos(x[sYAW]);
perception/MovingObstacleFuser/Filters.cc:1276:38:   Hx(oYVEL,sXPOS) = -vangleSensor_*cos(angleSensor_);
perception/MovingObstacleFuser/Filters.cc:1278:42:   Hx(oYVEL,sVEL) = -sin(angleSensor_)*cos(x[sYAW])+cos(angleSensor_)*sin(x[sYAW]);
perception/MovingObstacleFuser/Filters.cc:1279:63:   Hx(oYVEL,sYAW) = +sin(angleSensor_)*x[sVEL]*sin(x[sYAW])+cos(angleSensor_)*x[sVEL]*cos(x[sYAW]);
perception/MovingObstacleFuser/Filters.cc:1285:76:   Hx(oCORNERXPOS,sYAW)=-sin(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f-cos(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1286:35:   Hx(oCORNERYPOS,sYAW)=+cos(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f-sin(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1289:76:   Hx(oCORNERXPOS,sYAW)=-sin(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f+cos(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1290:35:   Hx(oCORNERYPOS,sYAW)=+cos(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f+sin(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1293:76:   Hx(oCORNERXPOS,sYAW)=+sin(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f+cos(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1294:35:   Hx(oCORNERYPOS,sYAW)=-cos(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f+sin(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1297:76:   Hx(oCORNERXPOS,sYAW)=+sin(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f-cos(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1298:35:   Hx(oCORNERYPOS,sYAW)=-cos(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f-sin(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1302:35:   Hx(oCORNERYPOS,sYAW)=+cos(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1306:35:   Hx(oCORNERYPOS,sYAW)=-cos(angle)*NOMINAL_VEHICLE_LENGTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1309:35:   Hx(oCORNERXPOS,sYAW)=-cos(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1313:35:   Hx(oCORNERXPOS,sYAW)=+cos(angle)*NOMINAL_VEHICLE_WIDTH_m/2.0f;
perception/MovingObstacleFuser/Filters.cc:1552:57:   v[SimpleBicycle::sVEL]=v[SimpleBicycle::sVEL]*cos(yawOld-yawNew);
perception/MovingObstacleFuser/Filters.cc:1649:42:   vel.x = v[SimpleBicycle::sVEL]*cos(v[SimpleBicycle::sYAW]);
perception/MovingObstacleFuser/Filters.cc:1717:36:   // ->this is wrong:   vx=v*cos(yaw), vy*sin(yaw) - linearize, then make an approximation.
perception/MovingObstacleFuser/Filters.cc:1815:40:   RecVector2D velocityError1(cos(tmp.rotZ)*std,sin(tmp.rotZ)*std); //assumed to be the worst case
perception/MovingObstacleFuser/Filters.cc:1816:40:   RecVector2D velocityError2(cos(tmp.rotZ+M_PI)*std,sin(tmp.rotZ+M_PI)*std); //assumed to be the worst case
perception/MovingObstacleFuser/Filters.cc:2334:51:   vel.x = this->operator()(SimpleBicycle::sVEL)*cos(yaw);
perception/MovingObstacleFuser/ARS300Sensor.cc:122:41:   RecVector2D sensorDirection(cos(sensorPose.rotZ),sin(sensorPose.rotZ));
perception/MovingObstacleFuser/ARS300Sensor.cc:195:33:   RecVector2D sensorDirection(cos(sensorPose.rotZ),sin(sensorPose.rotZ));
perception/MovingObstacleFuser/ARS300Sensor.cc:287:24:   boundaryPoint[0].x=cos(openingAngle);
perception/MovingObstacleFuser/ARS300Sensor.cc:292:24:   boundaryPoint[1].x=cos(-openingAngle);
perception/MovingObstacleFuser/ARS300Sensor.cc:297:24:   boundaryPoint[2].x=cos(-openingAngle);
perception/MovingObstacleFuser/ARS300Sensor.cc:302:24:   boundaryPoint[3].x=cos(+openingAngle);
perception/MovingObstacleFuser/ARS300Sensor.cc:383:32:   RecVector2D sensorAxis(cos(sensorPose.rotZ),sin(sensorPose.rotZ));
perception/MovingObstacleFuser/ARS300Sensor.cc:386:53:   if(fabs(sensorAxis.dot(sensorVelocityUnit))<cos(MAX_DELTA_ANGLE_VALIDATION_rad))
perception/MovingObstacleFuser/ObjectManagement.cc:2227:50:   if(fabs(dotProd)>cos(OM_MAX_ANGLE_MOVMENT_VERIFICATION_rad))
perception/MovingObstacleFuser/RoadShapeExtrapolator.cc:718:28:   velocities[ii].x = cos(poses[ii].rotZ)*speed_mps;
perception/MovingObstacleFuser/DummyMovingObjectSet.cc:216:46:   double linVel_mps = param.wheelVel_mps * cos(param.steerAngle_rad);
perception/MovingObstacleFuser/DummyMovingObjectSet.cc:220:26:   vel.x = linVel_mps * cos(param.pose.rotZ);
perception/RoadBlockageDetector/RoadBlockageDetector.cc:868:29:   RecVector2D dir(cos(pose.rotZ), sin(pose.rotZ));
perception/RoadBlockageDetector/RoadBlockageDetector.cc:977:21:   RecVector2D dir(cos(pose.rotZ), sin(pose.rotZ));
perception/modUtils/Linear.cc:73:5:   cos(phi) * cos(the) * cos(psi) + sin(phi) * sin(the) * sin(psi);
perception/modUtils/Linear.cc:75:16:   sin(phi) * cos(the) * cos(psi) - cos(phi) * sin(the) * sin(psi);
perception/modUtils/Linear.cc:77:5:   cos(phi) * sin(the) * cos(psi) + sin(phi) * cos(the) * sin(psi);
perception/modUtils/Linear.cc:79:5:   cos(phi) * cos(the) * sin(psi) - sin(phi) * sin(the) * cos(psi);
perception/modUtils/Linear.cc:131:23:   radians = double ( acos( quaternion[3] ) * 2 );
perception/modUtils/Linear.cc:254:28:   quaternion[3] = double ( cos( radians / 2 ) );
perception/modUtils/Linear.cc:300:11:   ** If cos(theta) < 0, use complement of theta as rotation angle.
perception/modUtils/Linear.cc:474:16:   omega = acos(cosOmega);
perception/modUtils/Linear.cc:591:17:   double cosy = cos(-yaw);
perception/modUtils/review/20070714/Linear.cc:73:12:   60 cos(phi) * cos(the) * cos(psi) + sin(phi) * sin(the) * sin(psi);
perception/modUtils/review/20070714/Linear.cc:75:23:   62 sin(phi) * cos(the) * cos(psi) - cos(phi) * sin(the) * sin(psi);
perception/modUtils/review/20070714/Linear.cc:77:12:   64 cos(phi) * sin(the) * cos(psi) + sin(phi) * cos(the) * sin(psi);
perception/modUtils/review/20070714/Linear.cc:79:12:   66 cos(phi) * cos(the) * sin(psi) - sin(phi) * sin(the) * cos(psi);
perception/modUtils/review/20070714/Linear.cc:131:30:   110 radians = double ( acos( quaternion[3] ) * 2 );
perception/modUtils/review/20070714/Linear.cc:254:35:   227 quaternion[3] = double ( cos( radians / 2 ) );
perception/modUtils/review/20070714/Linear.cc:300:18:   267 ** If cos(theta) < 0, use complement of theta as rotation angle.
perception/modUtils/review/20070714/Linear.cc:474:23:   424 omega = acos(cosOmega);
perception/modUtils/review/20070714/Linear.cc:591:24:   519 double cosy = cos(-yaw);
perception/modUtils/review/20070714/VehState.cc:38:22:   35 double cx = cos(heading_offset);
perception/modUtils/review/20070714/VehState.cc:55:22:   51 double cx = cos(-heading_offset);
perception/modUtils/review/20070714/Vec3d.cc:9:15:   6 x = cos(theta)*xorig + sin(theta)*y;
perception/modUtils/review/20070714/Vec3d.cc:10:34:   7 y = -sin(theta)*xorig + cos(theta)*y;
perception/modUtils/review/20070714/Vec3d.cc:137:38:   117 // Could return Math.acos(dot(v1)/v1.lensq()).
perception/modUtils/VehState.cc:38:15:   double cx = cos(heading_offset);
perception/modUtils/VehState.cc:55:15:   double cx = cos(-heading_offset);
perception/modUtils/Vec3d.cc:9:8:   x = cos(theta)*xorig + sin(theta)*y;
perception/modUtils/Vec3d.cc:10:27:   y = -sin(theta)*xorig + cos(theta)*y;
perception/modUtils/Vec3d.cc:137:31:   // Could return Math.acos(dot(v1)/v1.lensq()).
perception/ARS300Reader/review/20070715/ARS300Reader.cc:371:92:   341 target->absVelocitySensorCoord.x=vx+cos(angle)*sensorVx+sin(angle)*sensorVy;
perception/ARS300Reader/review/20070715/ARS300Reader.cc:372:112:   342 target->absVelocitySensorCoord.y=vy-sin(angle)*sensorVx+cos(angle)*sensorVy;
perception/ARS300Reader/ARS300Reader.cc:396:85:   target->absVelocitySensorCoord.x=vx+cos(angle)*sensorVx+sin(angle)*sensorVy;
perception/ARS300Reader/ARS300Reader.cc:397:105:   target->absVelocitySensorCoord.y=vy-sin(angle)*sensorVx+cos(angle)*sensorVy;
perception/GPSErrorEstimator/GPSErrorEstimator.cc:327:46:   RecVector2D expectedMotion(signOfSpeed * cos(lastState_.pose.rot1)* deltaT * curSpeed,
perception/GPSErrorEstimator/testGPSErrorMeasurementSource.cc:51:22:   RecVector2D perp(cos(laneCenter.rotZ+M_PI/2), sin(laneCenter.rotZ+M_PI/2));
perception/LidarIntensityLaneMarkerDetection/LidarIntensityLaneMarkerDetection.cc:809:19:   double angle=acos(ratio_);
perception/LidarIntensityLaneMarkerDetection/LidarIntensityLaneMarkerDetection.cc:816:20:   double w = cos(angleOfN);
perception/LidarIntensityLaneMarkerDetection/LidarIntensityLaneMarkerDetection.cc:851:12:   pt.x = cos(lr.azimuth_rad)*lr.range_m * cos(lr.elevation_rad);
perception/LidarIntensityLaneMarkerDetection/LidarIntensityLaneMarkerDetection.cc:852:45:   pt.y = sin(lr.azimuth_rad)*lr.range_m * cos(lr.elevation_rad);
perception/GeometryCurbDetector/GeometryCurbDetector.cc:892:19:   double angle=acos(ratio_);
perception/GeometryCurbDetector/GeometryCurbDetector.cc:899:20:   double w = cos(angleOfN);
perception/GeometryCurbDetector/GeometryCurbDetector.cc:934:9:	pt.x = cos(lr.azimuth_rad)*lr.range_m * cos(lr.elevation_rad);
perception/GeometryCurbDetector/GeometryCurbDetector.cc:935:42:	pt.y = sin(lr.azimuth_rad)*lr.range_m * cos(lr.elevation_rad);
simulator/statecontroller/src/generateenvironment.cpp:234:26:   TVector3D directionv(cos(angle),sin(angle),0 );
simulator/statecontroller/src/generateenvironment.cpp:318:26:   TVector3D directionv(cos(angle),sin(angle),0 );
simulator/viewer/src/SimView.cpp:372:17:   QuatD rotated(cos(angle),sin(angle),0,0);
simulator/viewer/src/SimView.cpp:728:27:   float cosTheta = (float)cos(angle);
simulator/viewer/src/visualizationloop.cpp:361:15:   QuatD ori(cos(angle2),0,0,sin(angle2));
simulator/viewer/src/interactwithworld.cpp:442:24:   TVector3D directionv(cos(angle),sin(angle),0 );
simulator/viewer/src/interactwithworld.cpp:456:27:   TVector3D directionvp(cos(anglep),sin(anglep),0 );
simulator/viewer/src/interactwithworld.cpp:457:24:   //double angle = (acos(dot(diffnext,directionvp)) - M_PI_2)/2.0 + anglep;
simulator/viewer/src/interactwithworld.cpp:458:26:   TVector3D directionv(cos(anglep),sin(anglep),0 );
simulator/viewer/src/interactwithworld.cpp:469:26:   directionv = TVector3D(cos(angle),sin(angle),0 );
simulator/viewer/src/interactwithworld.cpp:1148:26:   TVector3D directionv(cos(angle),sin(angle),0 );
simulator/viewer/src/interactwithworld.cpp:1189:26:   TVector3D directionv(cos(angle),sin(angle),0 );
simulator/viewer/src/terrain.cpp:554:20:   newx = (y/2+20)*cos(angle);
simulator/viewer/src/viewpositioning.cpp:161:14:   QuatD ori2(cos(angle3),0,sin(angle3),0);
simulator/viewer/src/viewpositioning.cpp:166:13:   QuatD ori(cos(angle2),0,sin(angle2),0);
simulator/robotclient/src/noisemodel.cpp:35:50:   double randvalue = sqrt(-2.0 * log(zerone1)) * cos(2.0 * M_PI * zerone2)*_stddev + _mean;
simulator/robotclient/src/generaterobotpose.cpp:265:45:   return dp->getPosition() - TVector3D( ora*cos(heading), ora*sin(heading),0);
simulator/robotclient/src/generateobstaclemap.cpp:65:20:   TVector3D offset(cos(robotorientation[2]) * OFFSETDIST_m,sin(robotorientation[2]) * OFFSETDIST_m,0);
simulator/common/primitives/src/DynamicPrim.cpp:222:44:   v1[0]= TVector3D((l2 - m_offsetrearaxle)*cos(heading),(l2 - m_offsetrearaxle)*sin(heading),0);
simulator/common/primitives/src/DynamicPrim.cpp:223:45:   v1[1]= TVector3D(-(l2 + m_offsetrearaxle)*cos(heading),-(l2 + m_offsetrearaxle)*sin(heading),0);
simulator/common/primitives/src/DynamicPrim.cpp:225:36:   TVector3D widthdiff(TVector3D(w2*cos(heading+M_PI_2),w2*sin(heading+M_PI_2),0));
simulator/common/primitives/src/DynamicPrim.cpp:319:32:   position[0] += arcLength * cos(orientation[2]);
simulator/common/primitives/src/DynamicPrim.cpp:321:36:   m_velocity = TVector3D(m_speed*cos(orientation[2]),m_speed*sin(orientation[2]),0);
simulator/common/primitives/src/DynamicPrim.cpp:333:36:   double cx = position[0] + radius*cos(orientation[2]-sgn*M_PI/2.0);
simulator/common/primitives/src/DynamicPrim.cpp:339:29:   position[0] = cx + radius*cos(theta-phi);
simulator/common/primitives/src/DynamicPrim.cpp:348:34:   m_velocity = TVector3D(m_speed*cos(orientation[2]),m_speed*sin(orientation[2]),0);
simulator/common/primitives/src/DynamicPrim.cpp:359:44:   v1[0]= TVector3D((l2 - m_offsetrearaxle)*cos(heading),(l2 - m_offsetrearaxle)*sin(heading),0);
simulator/common/primitives/src/DynamicPrim.cpp:360:45:   v1[1]= TVector3D(-(l2 + m_offsetrearaxle)*cos(heading),-(l2 + m_offsetrearaxle)*sin(heading),0);
simulator/common/primitives/src/DynamicPrim.cpp:362:36:   TVector3D widthdiff(TVector3D(w2*cos(heading+M_PI_2),w2*sin(heading+M_PI_2),0));
simulator/common/primitives/src/AreaPrim.cpp:378:30:   directionv = TVector3D(cos(angle),sin(angle),0 );
simulator/common/primitives/src/AreaPrim.cpp:390:32:   directionv = TVector3D(cos(angle),sin(angle),0 );
simulator/common/utilities/src/glutilities.cpp:63:29:   double angle = 360.0*acos(q.real())/M_PI;
simulator/math/math_tools.cpp:216:16:/*s =1/2 *sqrt(cos(theta)*cos(psi)+cos(psi)+cos(theta));
simulator/math/math_tools.cpp:219:13:(sin(theta)*cos(psi)+sin(theta)) /(2*s)
simulator/math/math_tools.cpp:220:11:(sin(psi)*cos(theta)+sin(psi))/(2*s)*/
simulator/math/math_tools.cpp:253:9:   a1 = acos(from[2]/psi);
simulator/math/math_tools.cpp:278:38:   float x = from[0] * sin(from[1]) * cos(from[2]);
simulator/math/math_tools.cpp:280:23:   float z = from[0] * cos(from[1]);
simulator/math/math_tools.cpp:287:17:   QuatD rot_psi(cos(vector[1]/2.0),0,0,sin(vector[1]/2.0));
simulator/math/math_tools.cpp:288:19:   //QuatD rot_psi(cos(-vector[1]/2.0),sin(-vector[1]/2.0),0,0);
simulator/math/math_tools.cpp:289:19:   QuatD rot_theta(cos((vector[2])/2.0),0,sin((vector[2])/2.0),0);
simulator/math/math_tools.cpp:349:16:   return QuatD(cos(heading/2.0),0,sin(heading/2.0),0);
simulator/math/math_tools.cpp:361:12:   QuatD pq(cos(p2), sin(p2), 0, 0);
simulator/math/math_tools.cpp:362:12:   QuatD rq(cos(r2), 0, sin(r2), 0);
simulator/math/math_tools.cpp:363:12:   QuatD yq(cos(y2), 0, 0, sin(y2));
simulator/math/quaterniont.h:142:11:   a = r * cos(phi);			// r*cos(phi)
simulator/math/quaterniont.h:143:26:   b = (d = r*sin(phi)) * cos(theta);	// r*sin(phi)*cos(theta)
simulator/math/quaterniont.h:144:27:   c = (d *= sin(theta)) * cos(psi);	// r*sin(phi)*sin(theta)*cos(psi)
utility/RailBot/RailBot.cc:420:48:   prim->setVelocity( speed_mps_ * TVector3D( cos(pose.rotZ),
utility/RailBot/RailBot.cc:497:48:   prim->setVelocity( speed_mps_ * TVector3D( cos(heading),
utility/RndfCheckpointExtractor/rndfCheckpointExtractor.cc:61:14:   double a=cos(latRad)*(longRad - longCenter);
utility/RndfCheckpointExtractor/rndfCheckpointExtractor.cc:62:25:   double c=eccPSq*sqr(cos(latRad));
utility/purePursuit/purePursuitTask.cc:168:45:   const RecVector2D headingVector(cos(rearDiffPose.rot1), sin(rearDiffPose.rot1));
utility/VelodyneToPoints/VelodyneToPoints.cc:91:21:   localPt.x = cos(ls[ii].azimuth_rad) * ls[ii].range_m * cos( ls[ii].elevation_rad );
utility/VelodyneToPoints/VelodyneToPoints.cc:92:64:   localPt.y = sin(ls[ii].azimuth_rad) * ls[ii].range_m * cos( ls[ii].elevation_rad );
behaviors/StateEstimator.cc:583:44:   const double dotProductThreshold = cos(headingDiff);
behaviors/StateEstimator.cc:680:56:   const double dotProductThreshold = cos(headingDiff);
behaviors/CurrentSceneReporter.cc:566:55:   const double minDot = cos(rr);
behaviors/review/20070829/StateEstimator.cc:439:51:   395 const double dotProductThreshold = cos(headingDiff);
behaviors/review/20070829/StateEstimator.cc:533:63:   482 const double dotProductThreshold = cos(headingDiff);
behaviors/review/20070829/GoalSelector.cc:1332:44:   1207 const double dotThreshold = cos(0.25 * PI);
behaviors/GoalSelector.cc:3430:40:   const double yDisp = 0.7 * xDisp * cos(1.1 * seconds); // 0.7 * xDisp to constrain goals to be kinda-kinematically feasible, 1.1 to minimize resonance
behaviors/DistanceKeeper.cc:595:65:   if((candidateHeadingVector * lookaheadVector) > cos(max_yaw_diff))
behaviors/DistanceKeeper.cc:603:73:   if((averageHeading * candidateDisplacementVector) > cos(max_connect_angle))
behaviors/DistanceKeeper.cc:619:99:   (averageHeading * candidateDisplacementVector.normal()), cos(max_connect_angle));
behaviors/DistanceKeeper.cc:624:82:   (candidateHeadingVector * lookaheadVector), cos(max_yaw_diff));
common/LidarUtils/LidarUtils.cc:57:15:   point.x = cos(pPoint.azimuth_rad)*pPoint.range_m * cos(pPoint.elevation_rad);
common/LidarUtils/LidarUtils.cc:58:56:   point.y = sin(pPoint.azimuth_rad)*pPoint.range_m * cos(pPoint.elevation_rad);
common/LidarUtils/review/20070712/LidarUtils.cc:57:22:   51 point.x = cos(pPoint.azimuth_rad)*pPoint.range_m * cos(pPoint.elevation_rad);
common/LidarUtils/review/20070712/LidarUtils.cc:58:63:   52 point.y = sin(pPoint.azimuth_rad)*pPoint.range_m * cos(pPoint.elevation_rad);
common/RoadWorldModel/Intersection.cc:129:25:   RecVector2D dir(cos(pose.rotZ), sin(pose.rotZ));
common/RoadWorldModel/RndfBuilder.cc:2113:25:   double dx = cos(pose.rotZ);
common/RoadWorldModel/RndfBuilder.cc:2139:25:   double dx = cos(pose.rotZ);
common/RoadWorldModel/RndfBuilder.cc:2196:20:   pose.x+=cos(pose.rotZ)*0.1;
common/RoadWorldModel/RndfBuilder.cc:2244:20:   pose.x-=cos(pose.rotZ)*0.1;
common/RoadWorldModel/RndfBuilder.cc:2262:16:   pose.x+=cos(pose.rotZ)*0.1;
common/RoadWorldModel/RndfBuilder.cc:2271:16:   pose.x-=cos(pose.rotZ)*0.1;
common/RoadWorldModel/testLaneKd.cc:372:29:   RecPoint2D vec( 5 * cos(r), 5 * sin(r) );
common/recgeometry/recTransform3D.cpp:207:8:   ca = cos(pose.rot1);
common/recgeometry/recTransform3D.cpp:208:8:   cb = cos(pose.rot2);
common/recgeometry/recTransform3D.cpp:209:8:   cg = cos(pose.rot3);
common/recgeometry/recTransform3D.cpp:513:13:	double c = cos(double(radAngle));
common/recgeometry/recTransform3D.cpp:536:13:	double c = cos(double(radAngle));
common/recgeometry/recTransform3D.cpp:559:13:	double c = cos(double(radAngle));
common/recgeometry/rectangleFitter.def.h:87:34:	tmp.x = (hullPts[ii].x-midPt.x)*cos(theta) + (hullPts[ii].y-midPt.y)*sin(theta);
common/recgeometry/rectangleFitter.def.h:88:72:	tmp.y = -(hullPts[ii].x-midPt.x)*sin(theta) + (hullPts[ii].y-midPt.y)*cos(theta);
common/recgeometry/rectangleFitter.def.h:93:18:	itmp.x = (tmp.x*cos(theta))-(tmp.y*sin(theta))+midPt.x;
common/recgeometry/rectangleFitter.def.h:94:37:	itmp.y = (tmp.x*sin(theta))+(tmp.y*cos(theta))+midPt.y;
common/recgeometry/rectangleFitter.def.h:95:24:	inewTmp.x = (newTmp.x*cos(theta))-(newTmp.y*sin(theta))+midPt.x;
common/recgeometry/rectangleFitter.def.h:96:46:	inewTmp.y = (newTmp.x*sin(theta))+(newTmp.y*cos(theta))+midPt.y;
common/recgeometry/rectangleFitter.def.h:148:43:   double tempX = (txPts[jj].x * cos(theta)) + (txPts[jj].y * sin(theta));
common/recgeometry/rectangleFitter.def.h:149:43:   double tempY = (txPts[jj].y * cos(theta)) - (txPts[jj].x * sin(theta));
common/recgeometry/rectangleFitter.def.h:182:25:	rotTmp.x = (transTmp.x*cos(finalTheta))+(transTmp.y*sin(finalTheta));
common/recgeometry/rectangleFitter.def.h:183:55:	rotTmp.y = -(transTmp.x*sin(finalTheta))+(transTmp.y*cos(finalTheta));
common/recgeometry/rectangleFitter.def.h:197:33:   rectCoordinates[0].x = maxL*cos(finalTheta) - maxW*sin(finalTheta) + clusterMean.x;
common/recgeometry/rectangleFitter.def.h:198:56:   rectCoordinates[0].y = maxL*sin(finalTheta) + maxW*cos(finalTheta) + clusterMean.y;
common/recgeometry/rectangleFitter.def.h:200:33:   rectCoordinates[1].x = maxL*cos(finalTheta) - minW*sin(finalTheta) + clusterMean.x;
common/recgeometry/rectangleFitter.def.h:201:56:   rectCoordinates[1].y = maxL*sin(finalTheta) + minW*cos(finalTheta) + clusterMean.y;
common/recgeometry/rectangleFitter.def.h:203:33:   rectCoordinates[2].x = minL*cos(finalTheta) - minW*sin(finalTheta) + clusterMean.x;
common/recgeometry/rectangleFitter.def.h:204:56:   rectCoordinates[2].y = minL*sin(finalTheta) + minW*cos(finalTheta) + clusterMean.y;
common/recgeometry/rectangleFitter.def.h:206:33:   rectCoordinates[3].x = minL*cos(finalTheta) - maxW*sin(finalTheta) + clusterMean.x;
common/recgeometry/rectangleFitter.def.h:207:56:   rectCoordinates[3].y = minL*sin(finalTheta) + maxW*cos(finalTheta) + clusterMean.y;
common/recgeometry/rectangleFitter.def.h:289:23:   double cosAngle = cos(angle);
common/recgeometry/rectangleFitter.def.h:464:27:   double cosAngle = cos(angle);
common/recgeometry/recPolygon2D.cpp:675:14:   ct = cos(theta);
common/recgeometry/recPolygon2D.cpp:707:10:   ct = cos(bestTheta);
common/recgeometry/recTransform2D.cpp:72:8:   ca = cos(pose.rotZ);
common/recgeometry/recTransform2D.cpp:159:13:	double c = cos(double(radAngle));
common/recgeometry/recVector2D.cpp:255:24:   return RecVector2D(cos(radians),sin(radians));
common/recgeometry/recPose3D.cpp:185:10:   cb = cos(rot2);
common/recgeometry/recPose3D.cpp:221:10:   cb = cos(rot2);
common/recgeometry/recPose3D.cpp:257:10:   cb = cos(rot2);
common/recgeometry/recPose3D.cpp:275:10:   cb = cos(rot2);
common/recgeometry/recPose3D.cpp:311:10:   cb = cos(rot2);
common/recgeometry/recPose3D.cpp:348:8:		cb = cos(rot2);
common/recgeometry/basicUnitTest.cc:1032:26:   TargetQuoi.quat[3] = cos(phi/2.0);
common/recgeometry/recQuaternion.cpp:246:18:   (*v) *= 1/sin(acos(quat[3]));
common/recgeometry/recQuaternion.cpp:248:10:	*phi = acos(quat[3]) * 2;
common/recgeometry/recQuaternion.cpp:265:13:   quat[3] = cos(phi/2.0);
common/MotionCommands/MotionCommands.cc:128:42:   isEquivalent = headingDot >= cos(tolerance.rotZ);
common/MotionCommands/MotionCommands.cc:145:46:   isEquivalent = headingDot >= cos(tolerance.rotZ);
common/Packetizer/GSOF/gsof_to_txyz.cc:124:20:   vd->Speed * cos(vd->Heading),
common/Packetizer/GSOF/gsof_display.cc:100:68:					snprintf((char *)&buf, 128, "North Vel:   % lfm/s", vd->Speed * cos(vd->Heading));
common/rtrt/Common/Primitives.h:329:43:			if (-sin(heading) * pRelativeToLS[0] + cos(heading) * pRelativeToLS[1] < 0)
common/RoadModelParticle/RoadModelParticle.cc:109:26:   return val + (dist * cos(theta));
common/RoadModelParticle/RoadModelParticle.cc:117:21:   RecVector2D vec(cos(pt.rotZ),sin(pt.rotZ));
common/RoadModelParticle/RoadModelParticle.cc:345:25:   RecVector2D vec(cos((*itr).rotZ),sin((*itr).rotZ));
common/RoadModelParticle/RoadModelParticle.cc:419:17:   double ds = cos(phi) * sqrt(relativeMotion.x*relativeMotion.x +
common/DatumShifter/DatumShifter.def.h:7:25:   x = (N + alt) * cos(lat) * cos(lon);
common/DatumShifter/DatumShifter.def.h:8:25:   y = (N + alt) * cos(lat) * sin(lon);
common/DatumShifter/DatumShifter.def.h:17:87:   lat = atan2((z + eprime * eprime * b * pow(sin(th), 3)), (p - e * e * a * pow(cos(th), 3)));
common/DatumShifter/DatumShifter.def.h:22:19:   alt = p / cos(lat) - N;
common/DatumShifter/review/20070817/DatumShifter.def.h:7:32:   5 x = (N + alt) * cos(lat) * cos(lon);
common/DatumShifter/review/20070817/DatumShifter.def.h:8:32:   6 y = (N + alt) * cos(lat) * sin(lon);
common/DatumShifter/review/20070817/DatumShifter.def.h:17:94:   13 lat = atan2((z + eprime * eprime * b * pow(sin(th), 3)), (p - e * e * a * pow(cos(th), 3)));
common/DatumShifter/review/20070817/DatumShifter.def.h:22:26:   16 alt = p / cos(lat) - N;
common/MovingObstacle/MovingObstacle.cc:729:25:   RecVector2D heading(cos(poseV[0].rotZ),sin(poseV[0].rotZ));
common/MovingObstacle/MovingObstacle.cc:802:23:   RecVector2D heading(cos(poseV[0].rotZ),sin(poseV[0].rotZ));
common/MovingObstacle/review/20070715/MovingObstacle.cc:545:32:   465 RecVector2D heading(cos(poseV[0].rotZ),sin(poseV[0].rotZ));
common/MovingObstacle/review/20070715/MovingObstacle.cc:618:30:   528 RecVector2D heading(cos(poseV[0].rotZ),sin(poseV[0].rotZ));
common/MovingTarget/review/20070715/MovingTarget.cc:72:30:   61 double c1=cos(angle1)*major;
common/MovingTarget/review/20070715/MovingTarget.cc:74:30:   63 double c2=cos(angle2)*major;
common/MovingTarget/MovingTarget.cc:81:23:   double c1=cos(angle1)*major;
common/MovingTarget/MovingTarget.cc:83:23:   double c2=cos(angle2)*major;
planning/Planner3D/planner3D.cpp:925:20:   double costh = cos(pose.theta);
planning/Planner3D/planner3D.cpp:979:20:   double costh = cos(pose->theta);
planning/Planner3D/planner3D.cpp:1098:20:   double costh = cos(pose->theta);
planning/Planner3D/planner3D.cpp:1388:67:								endPose.x = initialPose.x + actionDynamics->action.tv*dur*cos(initialPose.theta);
planning/Planner3D/planner3D.cpp:1444:19:								tvoverrv*(cos(actionDynamics->action.rv*ts+initialPose.theta)-cos(initialPose.theta));
planning/Planner3D/planner3D.cpp:1449:60:							newx = initialPose.x + actionDynamics->action.tv*ts*cos(initialPose.theta);
planning/Planner3D/Planner3DTaskUpdateFunctions.cc:462:79:   mapPoint.x += translationToLeftForDynamicObstacleHighCostRegions_m_ * cos(perpendicularTheta);
planning/Planner3D/Planner3DTaskUpdateFunctions.cc:1005:95:   //robotPose.x = robotPose.x + currentVehicleState_.speed_mps*(float)PLANNING_TIME_SEC/2.0*cos(robotPose.theta);
planning/Planner3D/utils.cpp:125:28:   double newx = pose1->x*cos(angle_rad) - pose1->y*sin(angle_rad);
planning/Planner3D/utils.cpp:126:54:   double newy = pose1->x*sin(angle_rad) + pose1->y*cos(angle_rad);
planning/Planner3D/SearchSpace2D.cpp:2150:23:   double cosAngle = cos((double)worldPose.rotZ);
planning/Planner3D/SearchSpace2D.cpp:2385:33:   //startPose.x = startPose.x - cos(startPose.theta)*REAR_AXLE_TO_CENTER_M;
planning/Planner3D/SearchSpace2D.cpp:2732:79:   int rear_axle_x = searchPose->x - (int)((REAR_AXLE_TO_CENTER/cellSize_m_)*cos((float)searchPose->theta*2.0*M_PI/(float)NUMOFANGLEVALS));
planning/LocalPlanner/DynamicObstacleChecker.cpp:291:18:   double costh = cos(pose->rotZ);
planning/LocalPlanner/DynamicObstacleChecker.cpp:470:23:   RecVector2D heading(cos(poseV.rotZ),sin(poseV.rotZ));
planning/LocalPlanner/UTurnPlanner.cpp:89:37:   arcTheta = M_PI/2 + fabs(acos((CONSERVATIVE_TURNING_RADIUS_M - extraDistanceAlongNormal)/CONSERVATIVE_TURNING_RADIUS_M));
planning/LocalPlanner/UTurnPlanner.cpp:91:28:   arcTheta = fabs(acos((CONSERVATIVE_TURNING_RADIUS_M - (distanceAlongNormal + laneWidth_m_/2.0))/CONSERVATIVE_TURNING_RADIUS_M));
planning/LocalPlanner/review/20070830/DynamicObstacleChecker.cpp:245:25:   206 double costh = cos(pose->rotZ);
planning/LocalPlanner/review/20070830/DynamicObstacleChecker.cpp:424:30:   356 RecVector2D heading(cos(poseV.rotZ),sin(poseV.rotZ));
planning/LocalPlanner/review/20070830/UTurnPlanner.cpp:89:44:   78 arcTheta = M_PI/2 + fabs(acos((CONSERVATIVE_TURNING_RADIUS_M - extraDistanceAlongNormal)/CONSERVATIVE_TURNING_RADIUS_M));
planning/LocalPlanner/review/20070830/UTurnPlanner.cpp:91:35:   80 arcTheta = fabs(acos((CONSERVATIVE_TURNING_RADIUS_M - (distanceAlongNormal + laneWidth_m_/2.0))/CONSERVATIVE_TURNING_RADIUS_M));
planning/LocalPlanner/review/20070830/SimpleTahoeVehicleModel.cpp:220:51:   189		next_state->x = current_state->x + v_dt * cos( current_state->yaw );		// determine the change in x
planning/LocalPlanner/review/20070830/ugc_initial_guess_table.cpp:219:76:   191 terminal_local_state.x = (terminal_state.x - initial_state.x) * cos(-(initial_state.yaw)) - (terminal_state.y - initial_state.y) * sin(-(initial_state.yaw));
planning/LocalPlanner/review/20070830/ugc_initial_guess_table.cpp:220:143:   192 terminal_local_state.y = (terminal_state.x - initial_state.x) * sin(-(initial_state.yaw)) + (terminal_state.y - initial_state.y) * cos(-(initial_state.yaw));
planning/LocalPlanner/review/20070830/LocalPlanner.cpp:1286:60:   1168 RecPoint2D currentHeadingVector(cos(nextVehicleState.yaw), sin(nextVehicleState.yaw));
planning/LocalPlanner/review/20070830/LocalPlanner.cpp:1480:44:   1356 RecPoint2D currentHeadingVector(cos(lookaheadVehicleState.yaw), sin(lookaheadVehicleState.yaw));
planning/LocalPlanner/review/20070830/LocalPlanner.cpp:1635:48:   1501 RecPoint2D initialHeadingVector(cos(lookaheadVehicleState.yaw), sin(lookaheadVehicleState.yaw));
planning/LocalPlanner/review/20070830/LocalPlanner.cpp:1820:71:   1678 desiredVehicleState.x += LARGE_SLOWING_DOWN_DISTANCE_M*cos(desiredVehicleState.yaw);
planning/LocalPlanner/review/20070830/LocalPlanner.cpp:1823:71:   1681 desiredVehicleState.x -= LARGE_SLOWING_DOWN_DISTANCE_M*cos(desiredVehicleState.yaw);
planning/LocalPlanner/review/20070830/LocalPlanner.cpp:1872:48:   1729 RecPoint2D currentHeadingVector(cos(currentVehicleState.yaw), sin(currentVehicleState.yaw));
planning/LocalPlanner/review/20070830/LocalPlanner.cpp:2128:68:   1978 desiredVehicleState.x -= BACKUP_DISTANCE_WHEN_STUCK*cos(desiredVehicleState.yaw);
planning/LocalPlanner/review/20070830/LocalPlanner.cpp:2707:44:   2532 RecPoint2D currentHeadingVector(cos(nextVehicleState.yaw), sin(nextVehicleState.yaw));
planning/LocalPlanner/review/20070830/LocalPlanner.cpp:2805:52:   2621 RecPoint2D currentHeadingVector(cos(nextVehicleState.yaw), sin(nextVehicleState.yaw));
planning/LocalPlanner/review/20070830/LocalPlanner.cpp:3045:94:   2842 desiredVehicleState.x = pathPoint.x - (double)laneRelativeToPath*laneWidth_m_*cos(pathPoint.yaw + LP_PI_OVER_2);
planning/LocalPlanner/review/20070830/LocalPlanner.cpp:3057:171:   2854 desiredVehicleState.x = pathPoint.x + ((double)perpendicularOffset/(double)numPointsToPlanPerpendicularToPath)*planningMaxPerpendicularDistanceFromPath_ * cos(pathPoint.yaw + LP_PI_OVER_2);
planning/LocalPlanner/review/20070830/intersectRectangles.cpp:22:23:   19 cosa = cos(ang),
planning/LocalPlanner/review/20070830/intersectRectangles.cpp:35:23:   30 cosa = cos(ang), // precalculated trigonometic -
planning/LocalPlanner/review/20070830/StrippedDownLocalPlannerTask.cc:245:48:   209 desiredVehicleState.x += 10.0*cos(desiredVehicleState.yaw);
planning/LocalPlanner/review/20070830/StrippedDownLocalPlannerTask.cc:250:48:   214 desiredVehicleState.y += -1.0*cos(desiredVehicleState.yaw);
planning/LocalPlanner/review/20070830/StrippedDownLocalPlannerTask.cc:260:48:   222 desiredVehicleState.x -= 10.0*cos(desiredVehicleState.yaw);
planning/LocalPlanner/review/20070830/StrippedDownLocalPlannerTask.cc:265:48:   226 desiredVehicleState.y += -1.0*cos(desiredVehicleState.yaw);
planning/LocalPlanner/review/20070830/LocalPlannerTask-functions.cc:300:31:   261 double costh = cos(currentVehicleState_.yaw);
planning/LocalPlanner/review/20070830/LocalPlannerTask-functions.cc:709:43:   647 double costh = cos(closestPoseInLane.rotZ);
planning/LocalPlanner/review/20070830/LocalPlannerTask-functions.cc:830:75:   759 leftSideLanePoint.x = currentLanePoint.x - 1.0*cos(currentVehicleState_.yaw + LP_PI_OVER_2);
planning/LocalPlanner/review/20070830/LocalPlannerTask-functions.cc:3177:98:   2979 globalGoal3DPosition.x = globalGoal3DPosition.x + ZONE_POSE_GOAL_GPS_BUFFER_M*cos((double)globalGoal3DPosition.rotZ);
planning/LocalPlanner/review/20070830/LocalPlannerTask-functions.cc:3249:44:   3046 costh = cos(newTheta);
planning/LocalPlanner/review/20070830/LocalPlannerTask-functions.cc:3495:73:   3284 uTurnGoalState_->x = newGoal.goalPose.x + 12.0*cos(newGoal.goalPose.rotZ); //10.0
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:217:61:   194 frontBumperState.y += (VEHICLEWIDTH_M/2)*cos(frontBumperState.yaw);
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:223:61:   200 frontBumperState.y -= (VEHICLEWIDTH_M/2)*cos(frontBumperState.yaw);
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:393:67:   363 frontBumperState.y += (VEHICLEWIDTH_M/2)*cos(frontBumperState.yaw);
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:399:67:   369 frontBumperState.y -= (VEHICLEWIDTH_M/2)*cos(frontBumperState.yaw);
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:499:25:   460 double costh = cos(vState->yaw);
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:722:25:   661 double costh = cos(vState->yaw);
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:726:160:   664 tahoeShape.corner[FL].x = vState->x + (REAR_AXLE_TO_FRONT_BUMPER_LENGTH)*costh - (VEHICLEWIDTH_M/2)*sinth; // using -sin(yaw) as it is equivalent to +cos(yaw+90)
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:727:126:   665 tahoeShape.corner[FL].y = vState->y + (REAR_AXLE_TO_FRONT_BUMPER_LENGTH)*sinth + (VEHICLEWIDTH_M/2)*costh; // using cos(yaw) as it is equivalent to sin(yaw+90)
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:747:25:   681 double costh = cos(vState->yaw);
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:751:192:   684 tahoeShape.corner[FL].x = vState->x + (REAR_AXLE_TO_FRONT_BUMPER_LENGTH + extraBuffer_m)*costh - (VEHICLEWIDTH_M/2 + extraBuffer_m)*sinth; // using -sin(yaw) as it is equivalent to +cos(yaw+90)
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:752:158:   685 tahoeShape.corner[FL].y = vState->y + (REAR_AXLE_TO_FRONT_BUMPER_LENGTH + extraBuffer_m)*sinth + (VEHICLEWIDTH_M/2 + extraBuffer_m)*costh; // using cos(yaw) as it is equivalent to sin(yaw+90)
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:771:27:   701 double costh = cos(vState->yaw);
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:775:172:   705 tahoeShape.corner[FL].x = vState->x + (OUTER_REAR_AXLE_TO_FRONT_BUMPER_LENGTH)*costh - (OUTER_VEHICLEWIDTH/2)*sinth; // using -sin(yaw) as it is equivalent to +cos(yaw+90)
planning/LocalPlanner/review/20070830/CollisionChecker.cpp:776:138:   706 tahoeShape.corner[FL].y = vState->y + (OUTER_REAR_AXLE_TO_FRONT_BUMPER_LENGTH)*sinth + (OUTER_VEHICLEWIDTH/2)*costh; // using cos(yaw) as it is equivalent to sin(yaw+90)
planning/LocalPlanner/SimpleTahoeVehicleModel.cpp:220:44:	next_state->x = current_state->x + v_dt * cos( current_state->yaw );		// determine the change in x
planning/LocalPlanner/ugc_initial_guess_table.cpp:237:69:   terminal_local_state.x = (terminal_state.x - initial_state.x) * cos(-(initial_state.yaw)) - (terminal_state.y - initial_state.y) * sin(-(initial_state.yaw));
planning/LocalPlanner/ugc_initial_guess_table.cpp:238:136:   terminal_local_state.y = (terminal_state.x - initial_state.x) * sin(-(initial_state.yaw)) + (terminal_state.y - initial_state.y) * cos(-(initial_state.yaw));
planning/LocalPlanner/LocalPlanner.cpp:1456:49:   RecPoint2D currentHeadingVector(cos(nextVehicleState.yaw), sin(nextVehicleState.yaw));
planning/LocalPlanner/LocalPlanner.cpp:1678:37:   RecPoint2D currentHeadingVector(cos(lookaheadVehicleState.yaw), sin(lookaheadVehicleState.yaw));
planning/LocalPlanner/LocalPlanner.cpp:1843:41:   RecPoint2D initialHeadingVector(cos(lookaheadVehicleState.yaw), sin(lookaheadVehicleState.yaw));
planning/LocalPlanner/LocalPlanner.cpp:2036:64:   desiredVehicleState.x += LARGE_SLOWING_DOWN_DISTANCE_M*cos(desiredVehicleState.yaw);
planning/LocalPlanner/LocalPlanner.cpp:2039:64:   desiredVehicleState.x -= LARGE_SLOWING_DOWN_DISTANCE_M*cos(desiredVehicleState.yaw);
planning/LocalPlanner/LocalPlanner.cpp:2088:41:   RecPoint2D currentHeadingVector(cos(currentVehicleState.yaw), sin(currentVehicleState.yaw));
planning/LocalPlanner/LocalPlanner.cpp:2357:65:   desiredVehicleState.x -= BACKUP_DISTANCE_WHEN_STUCK*cos(desiredVehicleState.yaw);
planning/LocalPlanner/LocalPlanner.cpp:2440:73:   pathOffsetVehicleState.x += pathOffsetForDefensiveDrivingInZones_m_*cos(M_PI/2.0 + pathOffsetVehicleState.yaw);
planning/LocalPlanner/LocalPlanner.cpp:3142:87:   desiredVehicleState.x = pathPoint.x - (double)laneRelativeToPath*laneWidth_m_*cos(pathPoint.yaw + LP_PI_OVER_2);
planning/LocalPlanner/LocalPlanner.cpp:3154:164:   desiredVehicleState.x = pathPoint.x + ((double)perpendicularOffset/(double)numPointsToPlanPerpendicularToPath)*planningMaxPerpendicularDistanceFromPath_ * cos(pathPoint.yaw + LP_PI_OVER_2);
planning/LocalPlanner/intersectRectangles.cpp:22:16:   cosa = cos(ang),
planning/LocalPlanner/intersectRectangles.cpp:35:16:   cosa = cos(ang), // precalculated trigonometic -
planning/LocalPlanner/StrippedDownLocalPlannerTask.cc:245:41:   desiredVehicleState.x += 10.0*cos(desiredVehicleState.yaw);
planning/LocalPlanner/StrippedDownLocalPlannerTask.cc:250:41:   desiredVehicleState.y += -1.0*cos(desiredVehicleState.yaw);
planning/LocalPlanner/StrippedDownLocalPlannerTask.cc:260:41:   desiredVehicleState.x -= 10.0*cos(desiredVehicleState.yaw);
planning/LocalPlanner/StrippedDownLocalPlannerTask.cc:265:41:   desiredVehicleState.y += -1.0*cos(desiredVehicleState.yaw);
planning/LocalPlanner/LocalPlannerTask-functions.cc:360:24:   double costh = cos(currentVehicleState_.yaw);
planning/LocalPlanner/LocalPlannerTask-functions.cc:799:36:   double costh = cos(closestPoseInLane.rotZ);
planning/LocalPlanner/LocalPlannerTask-functions.cc:928:80:   leftSideLanePoint.x = currentLanePoint.x - 1.0*cos(currentVehicleState_.yaw + LP_PI_OVER_2);
planning/LocalPlanner/LocalPlannerTask-functions.cc:1975:165:   //logger_.log_info("updating path point %d from %Lf %Lf v %Lf to %Lf %Lf v %lf\n", i, vehicleState->x, vehicleState->y, vehicleState->v, vehicleState->x + cos(vehicleState->yaw)*currentLaneWidth, vehicleState->y + sin(vehicleState->yaw)*currentLaneWidth, 0.0);
planning/LocalPlanner/LocalPlannerTask-functions.cc:1977:45:   vehicleState->x = vehicleState->x + cos(vehicleState->yaw + M_PI/2)*currentLaneWidth;
planning/LocalPlanner/LocalPlannerTask-functions.cc:3408:20:   double costh = cos(theta);
planning/LocalPlanner/LocalPlannerTask-functions.cc:3980:99:   globalGoal3DPosition.x = globalGoal3DPosition.x + ZONE_POSE_GOAL_GPS_BUFFER_M*cos((double)globalGoal3DPosition.rotZ);
planning/LocalPlanner/LocalPlannerTask-functions.cc:4048:37:   costh = cos(newTheta);
planning/LocalPlanner/LocalPlannerTask-functions.cc:4284:60:   lanePoint.x -= VEHICLELENGTH_M/2.0*cos(lanePoint.rotZ);
planning/LocalPlanner/LocalPlannerTask-functions.cc:4303:94:   newGoalWithCost.pose.x = lanePoint.x + lateralOffset*lateralSign*cos((double)lanePoint.rotZ + M_PI/2);
planning/LocalPlanner/LocalPlannerTask-functions.cc:4342:66:   xDiff = VEHICLELENGTH_M/2.0*(cos(lanePoint.rotZ) - cos(newGoalWithCost.pose.rotZ));
planning/LocalPlanner/LocalPlannerTask-functions.cc:4354:66:   xDiff = VEHICLELENGTH_M/2.0*(cos(lanePoint.rotZ) - cos(newGoalWithCost.pose.rotZ));
planning/LocalPlanner/LocalPlannerTask-functions.cc:4378:103:   newGoalWithCost.pose.x = globalGoal3DPosition.x + longitudinalOffset*sign*cos((double)globalGoal3DPosition.rotZ) + lateralOffset*lateralSign*cos((double)globalGoal3DPosition.rotZ + M_PI/2);
planning/LocalPlanner/LocalPlannerTask-functions.cc:4389:94:   frontBumper.x = newGoalWithCost.pose.x + VEHICLELENGTH_M/2.0*cos((double)newGoalWithCost.pose.rotZ);
planning/LocalPlanner/LocalPlannerTask-functions.cc:4391:93:   rearBumper.x = newGoalWithCost.pose.x - VEHICLELENGTH_M/2.0*cos((double)newGoalWithCost.pose.rotZ);
planning/LocalPlanner/LocalPlannerTask-functions.cc:4438:70:   xDiff = VEHICLELENGTH_M/2.0*(cos(globalGoal3DPosition.rotZ) - cos(newGoalWithCost.pose.rotZ));
planning/LocalPlanner/LocalPlannerTask-functions.cc:4454:70:   xDiff = VEHICLELENGTH_M/2.0*(cos(globalGoal3DPosition.rotZ) - cos(newGoalWithCost.pose.rotZ));
planning/LocalPlanner/LocalPlannerTask-functions.cc:4494:28:   double costh = cos((double)currentPose.rotZ);
planning/LocalPlanner/LocalPlannerTask-functions.cc:4741:66:   uTurnGoalState_->x = newGoal.goalPose.x + 12.0*cos(newGoal.goalPose.rotZ); //10.0
planning/LocalPlanner/CollisionChecker.cpp:259:54:   frontBumperState.y += (VEHICLEWIDTH_M/2)*cos(frontBumperState.yaw);
planning/LocalPlanner/CollisionChecker.cpp:265:54:   frontBumperState.y -= (VEHICLEWIDTH_M/2)*cos(frontBumperState.yaw);
planning/LocalPlanner/CollisionChecker.cpp:426:60:   frontBumperState.y += (VEHICLEWIDTH_M/2)*cos(frontBumperState.yaw);
planning/LocalPlanner/CollisionChecker.cpp:432:60:   frontBumperState.y -= (VEHICLEWIDTH_M/2)*cos(frontBumperState.yaw);
planning/LocalPlanner/CollisionChecker.cpp:525:18:   double costh = cos(vState->yaw);
planning/LocalPlanner/CollisionChecker.cpp:593:18:   double costh = cos(vState->yaw);
planning/LocalPlanner/CollisionChecker.cpp:875:18:   double costh = cos(vState->yaw);
planning/LocalPlanner/CollisionChecker.cpp:879:177:   tahoeShape.corner[FL].x = vState->x + (HARD_BUFFER_REAR_AXLE_TO_FRONT_BUMPER_LENGTH)*costh - (HARD_BUFFER_VEHICLEWIDTH_M/2)*sinth; // using -sin(yaw) as it is equivalent to +cos(yaw+90)
planning/LocalPlanner/CollisionChecker.cpp:880:143:   tahoeShape.corner[FL].y = vState->y + (HARD_BUFFER_REAR_AXLE_TO_FRONT_BUMPER_LENGTH)*sinth + (HARD_BUFFER_VEHICLEWIDTH_M/2)*costh; // using cos(yaw) as it is equivalent to sin(yaw+90)
planning/LocalPlanner/CollisionChecker.cpp:901:18:   double costh = cos(vState->yaw);
planning/LocalPlanner/CollisionChecker.cpp:905:189:   tahoeShape.corner[FL].x = vState->x + (OUTER_HARD_BUFFER_REAR_AXLE_TO_FRONT_BUMPER_LENGTH)*costh - (OUTER_HARD_BUFFER_VEHICLEWIDTH_M/2)*sinth; // using -sin(yaw) as it is equivalent to +cos(yaw+90)
planning/LocalPlanner/CollisionChecker.cpp:906:155:   tahoeShape.corner[FL].y = vState->y + (OUTER_HARD_BUFFER_REAR_AXLE_TO_FRONT_BUMPER_LENGTH)*sinth + (OUTER_HARD_BUFFER_VEHICLEWIDTH_M/2)*costh; // using cos(yaw) as it is equivalent to sin(yaw+90)
planning/LocalPlanner/CollisionChecker.cpp:927:18:   double costh = cos(vState->yaw);
planning/LocalPlanner/CollisionChecker.cpp:936:185:   tahoeShape.corner[FL].x = vState->x + (REAR_AXLE_TO_FRONT_BUMPER_LENGTH + extraBuffer_m)*costh - (VEHICLEWIDTH_M/2 + extraBuffer_m)*sinth; // using -sin(yaw) as it is equivalent to +cos(yaw+90)
planning/LocalPlanner/CollisionChecker.cpp:937:151:   tahoeShape.corner[FL].y = vState->y + (REAR_AXLE_TO_FRONT_BUMPER_LENGTH + extraBuffer_m)*sinth + (VEHICLEWIDTH_M/2 + extraBuffer_m)*costh; // using cos(yaw) as it is equivalent to sin(yaw+90)
planning/LocalPlanner/CollisionChecker.cpp:956:20:   double costh = cos(vState->yaw);
planning/LocalPlanner/CollisionChecker.cpp:960:165:   tahoeShape.corner[FL].x = vState->x + (OUTER_REAR_AXLE_TO_FRONT_BUMPER_LENGTH)*costh - (OUTER_VEHICLEWIDTH/2)*sinth; // using -sin(yaw) as it is equivalent to +cos(yaw+90)
planning/LocalPlanner/CollisionChecker.cpp:961:131:   tahoeShape.corner[FL].y = vState->y + (OUTER_REAR_AXLE_TO_FRONT_BUMPER_LENGTH)*sinth + (OUTER_VEHICLEWIDTH/2)*costh; // using cos(yaw) as it is equivalent to sin(yaw+90)
background/include/fdstar/fdstar.h:447:24:   *	nmap = NM_createmap_exp(-100, 100, -200, 200, 50, 50,
background/include/fdstar/fdstar.h:461:33:   *	flag = NM_flushwritecellcost_exp(nmap, 1000000, &count);
background/include/fdstar/fdstar.h:491:16:   *	NM_writemap_exp(nmap, 1000);
background/include/fdstar/fdstar.h:503:27:   * NM_compressandsavemap_exp(nmap, "mapfile");
background/include/fdstar/fdstar.h:522:26:   * newnmap = NM_growmap_exp(oldnmap, -1000, 1000, -2000, 2000);
examples/BayesExamples/BayesPVSIRExample.cc:149:23:   const Float Fvv = exp(-dt*V_GAMMA);
examples/BayesExamples/BayesPVExample.cc:150:23:   const Float Fvv = exp(-dt*V_GAMMA);
perception/DistanceTransform/misc.h:62:10:   return exp(-square(val/sigma)/2)/(sqrt(2*M_PI)*sigma);
perception/VelodyneSegmenter/VelodyneTracker.cc:362:34:   logPriorCar = log ( 1/ ( 1 + exp(distanceToLane - halfWidth) ) ); // nice sigmoid probability function
perception/VelodyneSegmenter/VelodyneTracker.cc:363:37:   logPriorNotCar = log ( 1/ ( 1 + exp(halfWidth - distanceToLane ) ) ); // nice sigmoid probability function
perception/RoadShapeFuser/ObstacleEvaluator.cc:117:41:   curScore = curScore * 0.8 *(exp(- (s*s) / (blockageDistanceSq)) + 0.2);
perception/RoadShapeFuser/ObstacleEvaluator.cc:130:19:   float A = 1 + exp((countSigmoidCenter_ - totalCount) * countSigmoidSlope_);
perception/RoadShapeFuser/RoadShapeFuser.cc:2177:42:   pf_.getParticle(pIdx).weight=exp(newValues[pIdx]-maxWeight);
perception/RoadShapeFuser/RoadShapeFuser.cc:2181:43:   pf_.getParticle(pIdx).weight*=exp(newValues[pIdx]-maxWeight);
perception/RoadShapeFuser/CurbEvaluator.cc:107:19:   float A = 1 + exp((countSigmoidCenter_ - totalCount) * countSigmoidSlope_);
perception/RoadShapeFuser/WaypointEvaluator.cc:81:24:   double decay = exp(decayRate_*(dist-decayOffset_));
simulator/math/math_tools.cpp:484:21:   return 1.0/(1.0 + exp(-v));
simulator/math/math_tools.cpp:518:57:   double result = (1.0/(stddev * sqrt(2.0 * M_PI))) * exp( -(xdiff * xdiff)/(2.0 * stddev*stddev));
behaviors/GoalSelector.cc:2078:56:   ii->distanceTo_m * exp(exponent);
common/RoadWorldModel/BlockedLinks.cc:141:26:   factor = exp( log(2) * (- age / halfLife_s) );
common/recgeometry/recGeometry.h:982:16:   angleToVertexP()
common/recgeometry/recPolygon2D.cpp:65:18:   angleToVertexP(poly.angleToVertexP)

perception/VelodyneViewer/trackballWindow/camera.cpp:619:28:   RecRadians rad = (2 * atan(12 / focallength));
perception/MovingObstacleFuser/Filters.cc:2307:26:   double tmp = m01*tan(phi);
utility/RndfCheckpointExtractor/rndfCheckpointExtractor.cc:64:14:   double t=tan(latRad);
common/RoadModelParticle/RoadModelParticle.cc:108:21:   double theta = atan(slope);
common/RoadModelParticle/RoadModelParticle.cc:498:12:   phi = atan(gsl_vector_get(cl,1));
#+END_CODE

* Goal

 - We have not concluded that the bugs affect the current code in Caddy.


 - But the question is, how do we know *for certain* that this behavior will not occur in other cases?

* Layers of Floating Point Computations

 - *Base level*: basic arithmetic operations [IEEE Standard]
 - *Library level*: standard floating point algorithms for evaluating elementrary functions
 - *Sensor driver level*: floating point computations on sensor data
 - *Control level*: complex algorithms in controller
 - *Actuator level*

* Bootstrapping Verification

 - IEEE standard on basic arithmetic operations can be assumed. (Hardware verification is advanced.)
 - Full verification of every function in the floating point library is needed. (Standard C Library in gcc should *not* be directly used!)
 - Verification of computations in sensor drivers.
 - Verification of control algorithms.

Techniques are recursively used.

* Big picture

Input:

 - Properties of basic operations
   ($+, -, \times, /, \sqrt{\text{ }}$) (IEEE954)
 - A C/C++ program $P$ computing a mathematical function $F$.
 - Tolerable error bound $\epsilon$.

* Big picture

Input:

 - Properties of basic operations
   ($+, -, \times, /, \sqrt{\text{ }}$) (IEEE954)
 - A C/C++ program $P$ computing a mathematical function $F$.
 - Tolerable error bound $\epsilon$.

Output:

 - Check that for all input $x$ in a reasonable range,

    $$||P(x) - F(x)|| < \epsilon $$

 - A *logical proof of correctness* with no errors.

* Methods

 - Encode programs as logic formulas
 - Solve using our nonlinear solver *dReal*
 - Produce *logical proofs of correctness*

* Encoding Programs into Logic Formulas

 - Assignment: $A(x,x')$
 - Branching: $(b\wedge C_1) \vee (\neg b \wedge C_2)$
 - Loops: $C(x_0,x_1) \wedge C(x_1, x_2) \wedge \dots$

$$\mathsf{Input}(x_0)\wedge \bigwedge_{i=0}^k \mathsf{Program}(x_i,x_{i+1})\wedge \mathsf{Property}(x_{k+1})$$

* Example

$$\textit{eglibc-2.14/libc/sysdeps/ieee754/dbl-64/s_sin.c}$$

#+BEGIN_CODE
/*******************************************************************/
/* An ultimate sin routine. Given an IEEE double machine number x   */
/* it computes the correctly rounded (to nearest) value of sin(x)  */
/*******************************************************************/
double __sin(double x){
        double xx,res,t,cor,y,s,c,sn,ssn,cs,ccs,xn,a,da,db,eps,xn1,xn2;
#if 0
        double w[2];
#endif
        mynumber u,v;
        int4 k,m,n;
#if 0
        int4 nn;
#endif

        u.x = x;
        m = u.i[HIGH_HALF];
        k = 0x7fffffff&m;              /* no sign           */
        if (k < 0x3e500000)            /* if x->0 =>sin(x)=x */
         return x;
 /*---------------------------- 2^-26 < |x|< 0.25 ----------------------*/
        else  if (k < 0x3fd00000){
          xx = x*x;
          /*Taylor series */
          t = ((((s5.x*xx + s4.x)*xx + s3.x)*xx + s2.x)*xx + s1.x)*(xx*x);
          res = x+t;
          cor = (x-res)+t;
          return (res == res + 1.07*cor)? res : slow(x);
        }    /*  else  if (k < 0x3fd00000)    */
/*---------------------------- 0.25<|x|< 0.855469---------------------- */
        else if (k < 0x3feb6000)  {
          u.x=(m>0)?big.x+x:big.x-x;
          y=(m>0)?x-(u.x-big.x):x+(u.x-big.x);
          xx=y*y;
          s = y + y*xx*(sn3 +xx*sn5);
          c = xx*(cs2 +xx*(cs4 + xx*cs6));
          k=u.i[LOW_HALF]<<2;
          sn=(m>0)?sincos.x[k]:-sincos.x[k];
          ssn=(m>0)?sincos.x[k+1]:-sincos.x[k+1];
          cs=sincos.x[k+2];
          ccs=sincos.x[k+3];
          cor=(ssn+s*ccs-sn*c)+cs*s;
          res=sn+cor;
          cor=(sn-res)+cor;
          return (res==res+1.025*cor)? res : slow1(x);
        }    /*   else  if (k < 0x3feb6000)    */

/*----------------------- 0.855469  <|x|<2.426265  ----------------------*/
        else if (k <  0x400368fd ) {

          y = (m>0)? hp0.x-x:hp0.x+x;
          if (y>=0) {
            u.x = big.x+y;
            y = (y-(u.x-big.x))+hp1.x;
          }
          else {
            u.x = big.x-y;
            y = (-hp1.x) - (y+(u.x-big.x));
          }
          xx=y*y;
          s = y + y*xx*(sn3 +xx*sn5);
          c = xx*(cs2 +xx*(cs4 + xx*cs6));
          k=u.i[LOW_HALF]<<2;
          sn=sincos.x[k];
          ssn=sincos.x[k+1];
          cs=sincos.x[k+2];
          ccs=sincos.x[k+3];
          cor=(ccs-s*ssn-cs*c)-sn*s;
          res=cs+cor;
          cor=(cs-res)+cor;
          return (res==res+1.020*cor)? ((m>0)?res:-res) : slow2(x);
        } /*   else  if (k < 0x400368fd)    */
#+END_CODE
* Example

$$\textit{eglibc-2.14/libc/sysdeps/ieee754/dbl-64/s_sin.c}$$

#+BEGIN_CODE
...

 /*---------------------------- 2^-26 < |x|< 0.25 ----------------------*/
        else  if (k < 0x3fd00000){
          xx = x*x;
          /*Taylor series */
          t = ((((s5.x*xx + s4.x)*xx + s3.x)*xx + s2.x)*xx + s1.x)*(xx*x);
          res = x+t;
          cor = (x-res)+t;
          return (res == res + 1.07*cor)? res : slow(x);
        }

...
#+END_CODE

\begin{align*}
& \forall x\in [2^{-26}, 0.25]  \\
& res = x + (s_5 \cdot x^8 + s_4 \cdot x^6 + s_3 \cdot x^4 + s_2 \cdot x^2 + s_1) \cdot x^3\\
& \land \quad res' = res + 1.07 cor \\
& \land \quad \lvert res' - \sin(x) \rvert < \varepsilon
\end{align*}

* Solving with *dReal*

 - *dReal* is our nonlinear logic solver.
 - Scalable on logical constraints with lots of nonlinear functions.

[[./img/dreal-screenshot.png]]

* Produce a proof of the correctness

 - We need to analyze algorithm in the solver and produce a logical
   proof of the correctness of the result.


 - This proof is checked with reliable logical proof-checker.

* Example
$$ \forall x \in [0, 0.25] \ \lvert \sin(x) - \mathrm{Program}(x) \rvert \stackrel{?}{<} 0.0001 $$
#+BEGIN_CODE
(set-logic QF_NRA)
(declare-fun x () Real)
(declare-fun res () Real)
(assert (<= 0.0 x))
(assert (<= x 0.25))
(assert (<= -1.0 res))
(assert (<= res 1.0))
(assert (= res
           (+ x
              (* (+ (*
                     (+ (*
                         (+ (*
                             (+ (* 0.00184028451407337715652
                                   (* x x)) 0.0266422703033638609560)
                             (* x x)) 0.146350472652464452805)
                         (* x x)) 0.325778796408930981787)
                     (* x x)) 0.214982415960608852501)
                 (* (* x x) x)))
           ))
(assert (not
         (and
          (<= (- res (sin x)) 0.0001)
          (<= (- (sin x) res) 0.0001))))
(check-sat)
#+END_CODE

$$\text{Found a Counterexample - 0.075 sec}$$

* Example
$$ \forall x \in [0, 0.25] \ \lvert \sin(x) - \mathrm{Program}(x) \rvert \stackrel{?}{<} 0.0001 $$


#+BEGIN_CODE
Counterexample (found in 0.075 seconds)
              x : [0.04414172137650908 , 0.04478236787698477];
            res : [0.04416026956711332 , 0.04486740116637928]
#+END_CODE

\begin{align*}
\sin([0.044142, 0.044782]) & \simeq  [0.0441602666, 0.044767034] \\
                        res & =      [0.0441602696, 0.044867402] \\
                \varepsilon & =      [0           , 0.000100368]
\end{align*}

* Example

$$ \forall x \in [0, 0.25] \ \lvert \sin(x) - \mathrm{Program}(x) \rvert \stackrel{?}{<} 0.01 $$

#+BEGIN_CODE
(set-logic QF_NRA)
(declare-fun x () Real)
(declare-fun res () Real)
(assert (<= 0.0 x))
(assert (<= x 0.25))
(assert (<= -1.0 res))
(assert (<= res 1.0))
(assert (= res
           (+ x
              (* (+ (*
                     (+ (*
                         (+ (*
                             (+ (* 0.00184028451407337715652
                                   (* x x)) 0.0266422703033638609560)
                             (* x x)) 0.146350472652464452805)
                         (* x x)) 0.325778796408930981787)
                     (* x x)) 0.214982415960608852501)
                 (* (* x x) x)))
           ))
(assert (not
         (and
          (<= (- res (sin x)) 0.01)
          (<= (- (sin x) res) 0.01))))
(check-sat)
#+END_CODE

$$\text{Proved - 0.012 sec}$$

* Example
$$ \text{Proof} $$
#+BEGIN_CODE
Precision:0.001
(= res (+ x (* (+ (* (+ (* (+ (* (+ (* 0.001840284514073377 (* x x))
0.02664227030336386) (* x x)) 0.1463504726524645) (* x x)) 0.325778796408931)
 (* x x)) 0.2149824159606089) (* (* x x) x))))
x: [0, 0.25];
res: [-1, 1];

[before pruning]
x: [0 , 0.25];
res: [-1 , +1]
[after pruning]
x: [0 , 0.25];
res: [0 , 0.253686278200172]

[before pruning]
x: [0 , 0.25];
res: [0 , 0.253686278200172]
[after pruning]
x: [0 , 0.25];
res: [0 , 0.253686278200172]

[before pruning]
x: [0 , 0.25];
res: [0 , 0.253686278200172]
[after pruning]
x: [0 , 0.25];
res: [0 , 0.253686278200172]

[before pruning]
x: [0 , 0.25];
res: [0 , 0.253686278200172]
[after pruning]
x: [0 , 0.25];
res: [0 , 0.253686278200172]

[before pruning]
x: [0 , 0.25];
res: [0 , 0.253686278200172]
[after pruning]
x: [0 , 0.25];
res: [0 , 0.253686278200172]

[before pruning]
x: [0 , 0.25];
res: [0 , 0.253686278200172]
[after pruning]
x: [0.0100001666741671 , 0.25];
res: [0 , 0.237403959254523]

[before pruning]
x: [0.0100001666741671 , 0.25];
res: [0 , 0.237403959254523]
[after pruning]
x: [0.0100001666741671 , 0.234399032583298];
res: [0 , 0.237403959254523]

[branched on res]
              x : [0.01000016667416711 , 0.2343990325832977];
            res : [0 , 0.237403959254523]

[before pruning]
x: [0.0100001666741671 , 0.234399032583298];
res: [0 , 0.118701979627261]
[after pruning]
x: [0.0100001666741671 , 0.234399032583298];
res: [0.0100003816999149 , 0.118701979627261]

[before pruning]
x: [0.0100001666741671 , 0.234399032583298];
res: [0.0100003816999149 , 0.118701979627261]
[after pruning]
x: [0.0100001666741671 , 0.234399032583298];
res: [0.0100003816999149 , 0.118701979627261]

[before pruning]
x: [0.0100001666741671 , 0.234399032583298];
res: [0.0100003816999149 , 0.118701979627261]
[after pruning]
x: [0.0200017153496697 , 0.234399032583298];
res: [0.0100003816999149 , 0.118701979627261]

[before pruning]
x: [0.0200017153496697 , 0.234399032583298];
res: [0.0100003816999149 , 0.118701979627261]
[after pruning]
x: [0.0200017153496697 , 0.118338105780926];
res: [0.0100003816999149 , 0.118701979627261]

[before pruning]
x: [0.0200017153496697 , 0.118338105780926];
res: [0.0100003816999149 , 0.118701979627261]
[after pruning]
x: [0.0200017153496697 , 0.118338105780926];
res: [0.0200034366946861 , 0.118701979627261]

[before pruning]
x: [0.0200017153496697 , 0.118338105780926];
res: [0.0200034366946861 , 0.118701979627261]
[after pruning]
x: [0.0200017153496697 , 0.118338105780926];
res: [0.0200034366946861 , 0.118701979627261]

[before pruning]
x: [0.0200017153496697 , 0.118338105780926];
res: [0.0200034366946861 , 0.118701979627261]
[after pruning]
x: [0.0300079400658978 , 0.118338105780926];
res: [0.0200034366946861 , 0.108062099799762]

[before pruning]
x: [0.0300079400658978 , 0.118338105780926];
res: [0.0200034366946861 , 0.108062099799762]
[after pruning]
x: [0.0300079400658978 , 0.118338105780926];
res: [0.0300137571312935 , 0.108062099799762]

[before pruning]
x: [0.0300079400658978 , 0.118338105780926];
res: [0.0300137571312935 , 0.108062099799762]
[after pruning]
x: [0.0300079400658978 , 0.118338105780926];
res: [0.0300137571312935 , 0.108062099799762]

[before pruning]
x: [0.0300079400658978 , 0.118338105780926];
res: [0.0300137571312935 , 0.108062099799762]
[after pruning]
x: [0.0400244425080067 , 0.118338105780926];
res: [0.0300137571312935 , 0.108062099799762]

[before pruning]
x: [0.0400244425080067 , 0.118338105780926];
res: [0.0300137571312935 , 0.108062099799762]
[after pruning]
x: [0.0400244425080067 , 0.118338105780926];
res: [0.0400382601065348 , 0.108062099799762]

[before pruning]
x: [0.0400244425080067 , 0.118338105780926];
res: [0.0400382601065348 , 0.108062099799762]
[after pruning]
x: [0.0400244425080067 , 0.118338105780926];
res: [0.0400382601065348 , 0.108062099799762]

[before pruning]
x: [0.0400244425080067 , 0.118338105780926];
res: [0.0400382601065348 , 0.108062099799762]
[after pruning]
x: [0.0500591648640404 , 0.118338105780926];
res: [0.0400382601065348 , 0.108062099799762]

[before pruning]
x: [0.0500591648640404 , 0.118338105780926];
res: [0.0400382601065348 , 0.108062099799762]
[after pruning]
x: [0.0500591648640404 , 0.118338105780926];
res: [0.0500862356994753 , 0.108062099799762]

[before pruning]
x: [0.0500591648640404 , 0.118338105780926];
res: [0.0500862356994753 , 0.108062099799762]
[after pruning]
x: [0.0500591648640404 , 0.118338105780926];
res: [0.0500862356994753 , 0.108062099799762]

[before pruning]
x: [0.0500591648640404 , 0.118338105780926];
res: [0.0500862356994753 , 0.108062099799762]
[after pruning]
x: [0.0601224500137962 , 0.118338105780926];
res: [0.0500862356994753 , 0.108062099799762]

[before pruning]
x: [0.0601224500137962 , 0.118338105780926];
res: [0.0500862356994753 , 0.108062099799762]
[after pruning]
x: [0.0601224500137962 , 0.118338105780926];
res: [0.0601694274389282 , 0.108062099799762]

[before pruning]
x: [0.0601224500137962 , 0.118338105780926];
res: [0.0601694274389282 , 0.108062099799762]
[after pruning]
x: [0.0601224500137962 , 0.118338105780926];
res: [0.0601694274389282 , 0.108062099799762]

[before pruning]
x: [0.0601224500137962 , 0.118338105780926];
res: [0.0601694274389282 , 0.108062099799762]
[after pruning]
x: [0.0702271381688987 , 0.118338105780926];
res: [0.0601694274389282 , 0.108062099799762]

[before pruning]
x: [0.0702271381688987 , 0.118338105780926];
res: [0.0601694274389282 , 0.108062099799762]
[after pruning]
x: [0.0702271381688987 , 0.118338105780926];
res: [0.0703021549923265 , 0.108062099799762]

[before pruning]
x: [0.0702271381688987 , 0.118338105780926];
res: [0.0703021549923265 , 0.108062099799762]
[after pruning]
x: [0.0702271381688987 , 0.118338105780926];
res: [0.0703021549923265 , 0.108062099799762]

[before pruning]
x: [0.0702271381688987 , 0.118338105780926];
res: [0.0703021549923265 , 0.108062099799762]
[after pruning]
x: [0.0803887102799322 , 0.118338105780926];
res: [0.0703021549923265 , 0.108062099799762]

[before pruning]
x: [0.0803887102799322 , 0.118338105780926];
res: [0.0703021549923265 , 0.108062099799762]
[after pruning]
x: [0.0803887102799322 , 0.118338105780926];
res: [0.0805014904288523 , 0.108062099799762]

[before pruning]
x: [0.0803887102799322 , 0.118338105780926];
res: [0.0805014904288523 , 0.108062099799762]
[after pruning]
x: [0.0803887102799322 , 0.118338105780926];
res: [0.0805014904288523 , 0.108062099799762]

[before pruning]
x: [0.0803887102799322 , 0.118338105780926];
res: [0.0805014904288523 , 0.108062099799762]
[after pruning]
x: [0.0906254903799893 , 0.118338105780926];
res: [0.0805014904288523 , 0.108062099799762]

[before pruning]
x: [0.0906254903799893 , 0.118338105780926];
res: [0.0805014904288523 , 0.108062099799762]
[after pruning]
x: [0.0906254903799893 , 0.118338105780926];
res: [0.0907875017632895 , 0.108062099799762]

[before pruning]
x: [0.0906254903799893 , 0.118338105780926];
res: [0.0907875017632895 , 0.108062099799762]
[after pruning]
x: [0.0906254903799893 , 0.118338105780926];
res: [0.0907875017632895 , 0.108062099799762]

[before pruning]
x: [0.0906254903799893 , 0.118338105780926];
res: [0.0907875017632895 , 0.108062099799762]
[after pruning]
x: [0.100958921777354 , 0.118338105780926];
res: [0.0907875017632895 , 0.108062099799762]

[before pruning]
x: [0.100958921777354 , 0.118338105780926];
res: [0.0907875017632895 , 0.108062099799762]
[after pruning]
x: [0.100958921777354 , 0.118338105780926];
res: [0.101183580913229 , 0.108062099799762]

[before pruning]
x: [0.100958921777354 , 0.118338105780926];
res: [0.101183580913229 , 0.108062099799762]
[after pruning]
x: [0.100958921777354 , 0.118338105780926];
res: [0.101183580913229 , 0.108062099799762]

[before pruning]
x: [0.100958921777354 , 0.118338105780926];
res: [0.101183580913229 , 0.108062099799762]
[after pruning]
x: [0.111413935970023 , 0.118338105780926];
res: [0.101183580913229 , 0.108062099799762]

[before pruning]
x: [0.111413935970023 , 0.118338105780926];
res: [0.101183580913229 , 0.108062099799762]
[conflict detected]

[before pruning]
x: [0.0100001666741671 , 0.234399032583298];
res: [0.118701979627261 , 0.237403959254523]
[after pruning]
x: [0.0100001666741671 , 0.234399032583298];
res: [0.118701979627261 , 0.237403959254523]

[before pruning]
x: [0.0100001666741671 , 0.234399032583298];
res: [0.118701979627261 , 0.237403959254523]
[after pruning]
x: [0.108917198589384 , 0.234399032583298];
res: [0.118701979627261 , 0.237403959254523]

[before pruning]
x: [0.108917198589384 , 0.234399032583298];
res: [0.118701979627261 , 0.237403959254523]
[after pruning]
x: [0.129059962006778 , 0.234399032583298];
res: [0.118701979627261 , 0.222258494069181]

[before pruning]
x: [0.129059962006778 , 0.234399032583298];
res: [0.118701979627261 , 0.222258494069181]
[after pruning]
x: [0.129059962006778 , 0.234399032583298];
res: [0.129533858674241 , 0.222258494069181]

[before pruning]
x: [0.129059962006778 , 0.234399032583298];
res: [0.129533858674241 , 0.222258494069181]
[after pruning]
x: [0.129059962006778 , 0.234399032583298];
res: [0.129533858674241 , 0.222258494069181]

[before pruning]
x: [0.129059962006778 , 0.234399032583298];
res: [0.129533858674241 , 0.222258494069181]
[after pruning]
x: [0.139990652580917 , 0.234399032583298];
res: [0.129533858674241 , 0.222258494069181]

[before pruning]
x: [0.139990652580917 , 0.234399032583298];
res: [0.129533858674241 , 0.222258494069181]
[after pruning]
x: [0.139990652580917 , 0.234399032583298];
res: [0.140598116246857 , 0.222258494069181]

[before pruning]
x: [0.139990652580917 , 0.234399032583298];
res: [0.140598116246857 , 0.222258494069181]
[after pruning]
x: [0.139990652580917 , 0.234399032583298];
res: [0.140598116246857 , 0.222258494069181]

[before pruning]
x: [0.139990652580917 , 0.234399032583298];
res: [0.140598116246857 , 0.222258494069181]
[after pruning]
x: [0.151173261353647 , 0.234399032583298];
res: [0.140598116246857 , 0.222258494069181]

[before pruning]
x: [0.151173261353647 , 0.234399032583298];
res: [0.140598116246857 , 0.222258494069181]
[after pruning]
x: [0.151173261353647 , 0.234399032583298];
res: [0.151941972842422 , 0.222258494069181]

[before pruning]
x: [0.151173261353647 , 0.234399032583298];
res: [0.151941972842422 , 0.222258494069181]
[after pruning]
x: [0.151173261353647 , 0.234399032583298];
res: [0.151941972842422 , 0.222258494069181]

[before pruning]
x: [0.151173261353647 , 0.234399032583298];
res: [0.151941972842422 , 0.222258494069181]
[after pruning]
x: [0.162658285759063 , 0.234399032583298];
res: [0.151941972842422 , 0.222258494069181]

[before pruning]
x: [0.162658285759063 , 0.234399032583298];
res: [0.151941972842422 , 0.222258494069181]
[after pruning]
x: [0.162658285759063 , 0.234399032583298];
res: [0.163621014022482 , 0.222258494069181]

[before pruning]
x: [0.162658285759063 , 0.234399032583298];
res: [0.163621014022482 , 0.222258494069181]
[after pruning]
x: [0.162658285759063 , 0.234399032583298];
res: [0.163621014022482 , 0.222258494069181]

[before pruning]
x: [0.162658285759063 , 0.234399032583298];
res: [0.163621014022482 , 0.222258494069181]
[after pruning]
x: [0.174505342579056 , 0.234399032583298];
res: [0.163621014022482 , 0.222258494069181]

[before pruning]
x: [0.174505342579056 , 0.234399032583298];
res: [0.163621014022482 , 0.222258494069181]
[after pruning]
x: [0.174505342579056 , 0.234399032583298];
res: [0.175701215443861 , 0.222258494069181]

[before pruning]
x: [0.174505342579056 , 0.234399032583298];
res: [0.175701215443861 , 0.222258494069181]
[after pruning]
x: [0.174505342579056 , 0.234399032583298];
res: [0.175701215443861 , 0.222258494069181]

[before pruning]
x: [0.174505342579056 , 0.234399032583298];
res: [0.175701215443861 , 0.222258494069181]
[after pruning]
x: [0.186785442382281 , 0.234399032583298];
res: [0.175701215443861 , 0.222258494069181]

[before pruning]
x: [0.186785442382281 , 0.234399032583298];
res: [0.175701215443861 , 0.222258494069181]
[after pruning]
x: [0.186785442382281 , 0.234399032583298];
res: [0.188261660180559 , 0.222258494069181]

[before pruning]
x: [0.186785442382281 , 0.234399032583298];
res: [0.188261660180559 , 0.222258494069181]
[after pruning]
x: [0.186785442382281 , 0.234399032583298];
res: [0.188261660180559 , 0.222258494069181]

[before pruning]
x: [0.186785442382281 , 0.234399032583298];
res: [0.188261660180559 , 0.222258494069181]
[after pruning]
x: [0.199584055359514 , 0.234399032583298];
res: [0.188261660180559 , 0.222258494069181]

[before pruning]
x: [0.199584055359514 , 0.234399032583298];
res: [0.188261660180559 , 0.222258494069181]
[after pruning]
x: [0.199584055359514 , 0.234399032583298];
res: [0.201398235769772 , 0.222258494069181]

[before pruning]
x: [0.199584055359514 , 0.234399032583298];
res: [0.201398235769772 , 0.222258494069181]
[after pruning]
x: [0.199584055359514 , 0.234399032583298];
res: [0.201398235769772 , 0.222258494069181]

[before pruning]
x: [0.199584055359514 , 0.234399032583298];
res: [0.201398235769772 , 0.222258494069181]
[after pruning]
x: [0.213005305551911 , 0.234399032583298];
res: [0.201398235769772 , 0.222258494069181]

[before pruning]
x: [0.213005305551911 , 0.234399032583298];
res: [0.201398235769772 , 0.222258494069181]
[after pruning]
x: [0.213005305551911 , 0.234399032583298];
res: [0.215228748170461 , 0.222258494069181]

[before pruning]
x: [0.213005305551911 , 0.234399032583298];
res: [0.215228748170461 , 0.222258494069181]
[after pruning]
x: [0.213005305551911 , 0.234399032583298];
res: [0.215228748170461 , 0.222258494069181]

[before pruning]
x: [0.213005305551911 , 0.234399032583298];
res: [0.215228748170461 , 0.222258494069181]
[after pruning]
x: [0.227177810454706 , 0.234399032583298];
res: [0.215228748170461 , 0.222258494069181]

[before pruning]
x: [0.227177810454706 , 0.234399032583298];
res: [0.215228748170461 , 0.222258494069181]
[conflict detected]

[before pruning]
x: [0 , 0.25];
res: [0 , 0.253686278200172]
[after pruning]
x: [0 , 0.25];
res: [0 , 0.253686278200172]

[before pruning]
x: [0 , 0.25];
res: [0 , 0.253686278200172]
[after pruning]
x: [0 , 0.246164905434643];
res: [0.01 , 0.253686278200172]

[before pruning]
x: [0 , 0.246164905434643];
res: [0.01 , 0.253686278200172]
[after pruning]
x: [0.00999978436854053 , 0.246164905434643];
res: [0.01 , 0.253686278200172]

[before pruning]
x: [0.00999978436854053 , 0.246164905434643];
res: [0.01 , 0.253686278200172]
[after pruning]
x: [0.00999978436854053 , 0.246164905434643];
res: [0.01 , 0.249674359014133]

[before pruning]
x: [0.00999978436854053 , 0.246164905434643];
res: [0.01 , 0.249674359014133]
[after pruning]
x: [0.00999978436854053 , 0.242030419864151];
res: [0.0199996177134884 , 0.249674359014133]

[before pruning]
x: [0.00999978436854053 , 0.242030419864151];
res: [0.0199996177134884 , 0.249674359014133]
[after pruning]
x: [0.00999978436854053 , 0.242030419864151];
res: [0.0199996177134884 , 0.249674359014133]

[before pruning]
x: [0.00999978436854053 , 0.242030419864151];
res: [0.0199996177134884 , 0.249674359014133]
[after pruning]
x: [0.019997894922144 , 0.242030419864151];
res: [0.0199996177134884 , 0.249674359014133]

[before pruning]
x: [0.019997894922144 , 0.242030419864151];
res: [0.0199996177134884 , 0.249674359014133]
[after pruning]
x: [0.019997894922144 , 0.242030419864151];
res: [0.0199996177134884 , 0.245356166599806]

[before pruning]
x: [0.019997894922144 , 0.242030419864151];
res: [0.0199996177134884 , 0.245356166599806]
[after pruning]
x: [0.019997894922144 , 0.237585012623623];
res: [0.0299965620364343 , 0.245356166599806]

[before pruning]
x: [0.019997894922144 , 0.237585012623623];
res: [0.0299965620364343 , 0.245356166599806]
[after pruning]
x: [0.019997894922144 , 0.237585012623623];
res: [0.0299965620364343 , 0.245356166599806]

[before pruning]
x: [0.019997894922144 , 0.237585012623623];
res: [0.0299965620364343 , 0.245356166599806]
[after pruning]
x: [0.0299907517838823 , 0.237585012623623];
res: [0.0299965620364343 , 0.245356166599806]

[branched on res]
              x : [0.02999075178388229 , 0.2375850126236231];
            res : [0.02999656203643434 , 0.2453561665998056]

[before pruning]
x: [0.0299907517838823 , 0.237585012623623];
res: [0.0299965620364343 , 0.13767636431812]
[after pruning]
x: [0.0299907517838823 , 0.237585012623623];
res: [0.0299965620364343 , 0.13767636431812]

[before pruning]
x: [0.0299907517838823 , 0.237585012623623];
res: [0.0299965620364343 , 0.13767636431812]
[after pruning]
x: [0.0299907517838823 , 0.128025814659624];
res: [0.0399862561464805 , 0.13767636431812]

[before pruning]
x: [0.0299907517838823 , 0.128025814659624];
res: [0.0399862561464805 , 0.13767636431812]
[after pruning]
x: [0.0299907517838823 , 0.128025814659624];
res: [0.0399862561464805 , 0.13767636431812]

[before pruning]
x: [0.0299907517838823 , 0.128025814659624];
res: [0.0399862561464805 , 0.13767636431812]
[after pruning]
x: [0.0299907517838823 , 0.128025814659624];
res: [0.0399862561464805 , 0.128488226014117]

[before pruning]
x: [0.0299907517838823 , 0.128025814659624];
res: [0.0399862561464805 , 0.128488226014117]
[after pruning]
x: [0.0299907517838823 , 0.118767244181742];
res: [0.0399862561464805 , 0.128488226014117]

[before pruning]
x: [0.0299907517838823 , 0.118767244181742];
res: [0.0399862561464805 , 0.128488226014117]
[after pruning]
x: [0.0399724899089758 , 0.118767244181742];
res: [0.0399862561464805 , 0.128488226014117]

[before pruning]
x: [0.0399724899089758 , 0.118767244181742];
res: [0.0399862561464805 , 0.128488226014117]
[after pruning]
x: [0.0399724899089758 , 0.118767244181742];
res: [0.0399862561464805 , 0.119135149518705]

[before pruning]
x: [0.0399724899089758 , 0.118767244181742];
res: [0.0399862561464805 , 0.119135149518705]
[after pruning]
x: [0.0399724899089758 , 0.109352960976039];
res: [0.0499618460856199 , 0.119135149518705]

[before pruning]
x: [0.0399724899089758 , 0.109352960976039];
res: [0.0499618460856199 , 0.119135149518705]
[after pruning]
x: [0.0399724899089758 , 0.109352960976039];
res: [0.0499618460856199 , 0.119135149518705]

[before pruning]
x: [0.0399724899089758 , 0.109352960976039];
res: [0.0499618460856199 , 0.119135149518705]
[after pruning]
x: [0.0399724899089758 , 0.109352960976039];
res: [0.0499618460856199 , 0.109639204432078]

[before pruning]
x: [0.0399724899089758 , 0.109352960976039];
res: [0.0499618460856199 , 0.109639204432078]
[after pruning]
x: [0.0399724899089758 , 0.0998048145715705];
res: [0.0499618460856199 , 0.109639204432078]

[before pruning]
x: [0.0399724899089758 , 0.0998048145715705];
res: [0.0499618460856199 , 0.109639204432078]
[after pruning]
x: [0.0399724899089758 , 0.0998048145715705];
res: [0.0499618460856199 , 0.100021781180612]

[before pruning]
x: [0.0399724899089758 , 0.0998048145715705];
res: [0.0499618460856199 , 0.100021781180612]
[after pruning]
x: [0.0399724899089758 , 0.0998048145715705];
res: [0.0499618460856199 , 0.100021781180612]

[before pruning]
x: [0.0399724899089758 , 0.0998048145715705];
res: [0.0499618460856199 , 0.100021781180612]
[after pruning]
x: [0.0399724899089758 , 0.0901438149701431];
res: [0.0499618460856199 , 0.100021781180612]

[before pruning]
x: [0.0399724899089758 , 0.0901438149701431];
res: [0.0499618460856199 , 0.100021781180612]
[after pruning]
x: [0.0399724899089758 , 0.0901438149701431];
res: [0.0499618460856199 , 0.0903032358516316]

[before pruning]
x: [0.0399724899089758 , 0.0901438149701431];
res: [0.0499618460856199 , 0.0903032358516316]
[after pruning]
x: [0.0399724899089758 , 0.080389794641156];
res: [0.0499618460856199 , 0.0903032358516316]

[before pruning]
x: [0.0399724899089758 , 0.080389794641156];
res: [0.0499618460856199 , 0.0903032358516316]
[after pruning]
x: [0.0399724899089758 , 0.080389794641156];
res: [0.0499618460856199 , 0.0903032358516316]

[before pruning]
x: [0.0399724899089758 , 0.080389794641156];
res: [0.0499618460856199 , 0.0903032358516316]
[after pruning]
x: [0.0399724899089758 , 0.080389794641156];
res: [0.0499618460856199 , 0.0805025793836819]

[before pruning]
x: [0.0399724899089758 , 0.080389794641156];
res: [0.0499618460856199 , 0.0805025793836819]
[after pruning]
x: [0.0399724899089758 , 0.0705611172623982];
res: [0.0499618460856199 , 0.0805025793836819]

[before pruning]
x: [0.0399724899089758 , 0.0705611172623982];
res: [0.0499618460856199 , 0.0805025793836819]
[after pruning]
x: [0.0399724899089758 , 0.0705611172623982];
res: [0.0499618460856199 , 0.0706372148614746]

[before pruning]
x: [0.0399724899089758 , 0.0705611172623982];
res: [0.0499618460856199 , 0.0706372148614746]
[after pruning]
x: [0.0399724899089758 , 0.0705611172623982];
res: [0.0499618460856199 , 0.0706372148614746]

[before pruning]
x: [0.0399724899089758 , 0.0705611172623982];
res: [0.0499618460856199 , 0.0706372148614746]
[after pruning]
x: [0.0399724899089758 , 0.0606744356908778];
res: [0.0499618460856199 , 0.0706372148614746]

[before pruning]
x: [0.0399724899089758 , 0.0606744356908778];
res: [0.0499618460856199 , 0.0706372148614746]
[after pruning]
x: [0.0399724899089758 , 0.0606744356908778];
res: [0.0499618460856199 , 0.0607227238023179]

[before pruning]
x: [0.0399724899089758 , 0.0606744356908778];
res: [0.0499618460856199 , 0.0607227238023179]
[after pruning]
x: [0.0399724899089758 , 0.050744498881259];
res: [0.0499618460856199 , 0.0607227238023179]

[before pruning]
x: [0.0399724899089758 , 0.050744498881259];
res: [0.0499618460856199 , 0.0607227238023179]
[after pruning]
x: [0.0399724899089758 , 0.050744498881259];
res: [0.0499618460856199 , 0.0607227238023179]

[before pruning]
x: [0.0399724899089758 , 0.050744498881259];
res: [0.0499618460856199 , 0.0607227238023179]
[after pruning]
x: [0.0399724899089758 , 0.050744498881259];
res: [0.0499618460856199 , 0.0507726997935221]

[before pruning]
x: [0.0399724899089758 , 0.050744498881259];
res: [0.0499618460856199 , 0.0507726997935221]
[after pruning]
x: [0.0399724899089758 , 0.040784005097597];
res: [0.0499618460856199 , 0.0507726997935221]

[before pruning]
x: [0.0399724899089758 , 0.040784005097597];
res: [0.0499618460856199 , 0.0507726997935221]
[conflict detected]

[before pruning]
x: [0.0299907517838823 , 0.237585012623623];
res: [0.13767636431812 , 0.245356166599806]
[after pruning]
x: [0.0299907517838823 , 0.237585012623623];
res: [0.13767636431812 , 0.240721047223944]

[before pruning]
x: [0.0299907517838823 , 0.237585012623623];
res: [0.13767636431812 , 0.240721047223944]
[after pruning]
x: [0.0299907517838823 , 0.232818658380484];
res: [0.13767636431812 , 0.240721047223944]

[before pruning]
x: [0.0299907517838823 , 0.232818658380484];
res: [0.13767636431812 , 0.240721047223944]
[after pruning]
x: [0.0299907517838823 , 0.232818658380484];
res: [0.13767636431812 , 0.240721047223944]

[before pruning]
x: [0.0299907517838823 , 0.232818658380484];
res: [0.13767636431812 , 0.240721047223944]
[after pruning]
x: [0.137106359274534 , 0.232818658380484];
res: [0.13767636431812 , 0.240721047223944]

[before pruning]
x: [0.137106359274534 , 0.232818658380484];
res: [0.13767636431812 , 0.240721047223944]
[after pruning]
x: [0.137106359274534 , 0.232818658380484];
res: [0.13767636431812 , 0.235760028700917]

[before pruning]
x: [0.137106359274534 , 0.232818658380484];
res: [0.13767636431812 , 0.235760028700917]
[after pruning]
x: [0.137106359274534 , 0.227723136146858];
res: [0.146677205101456 , 0.235760028700917]

[before pruning]
x: [0.137106359274534 , 0.227723136146858];
res: [0.146677205101456 , 0.235760028700917]
[after pruning]
x: [0.137106359274534 , 0.227723136146858];
res: [0.146677205101456 , 0.235760028700917]

[before pruning]
x: [0.137106359274534 , 0.227723136146858];
res: [0.146677205101456 , 0.235760028700917]
[after pruning]
x: [0.145986523936967 , 0.227723136146858];
res: [0.146677205101456 , 0.235760028700917]

[branched on res]
              x : [0.1459865239369674 , 0.2277231361468578];
            res : [0.1466772051014564 , 0.2357600287009166]

[before pruning]
x: [0.145986523936967 , 0.227723136146858];
res: [0.146677205101456 , 0.191218616901187]
[after pruning]
x: [0.145986523936967 , 0.227723136146858];
res: [0.146677205101456 , 0.191218616901187]

[before pruning]
x: [0.145986523936967 , 0.227723136146858];
res: [0.146677205101456 , 0.191218616901187]
[after pruning]
x: [0.145986523936967 , 0.182225443563193];
res: [0.15546853050196 , 0.191218616901187]

[before pruning]
x: [0.145986523936967 , 0.182225443563193];
res: [0.15546853050196 , 0.191218616901187]
[after pruning]
x: [0.145986523936967 , 0.182225443563193];
res: [0.15546853050196 , 0.191218616901187]

[before pruning]
x: [0.145986523936967 , 0.182225443563193];
res: [0.15546853050196 , 0.191218616901187]
[after pruning]
x: [0.145986523936967 , 0.182225443563193];
res: [0.15546853050196 , 0.183592743008892]

[before pruning]
x: [0.145986523936967 , 0.182225443563193];
res: [0.15546853050196 , 0.183592743008892]
[after pruning]
x: [0.145986523936967 , 0.174476635651758];
res: [0.15546853050196 , 0.183592743008892]

[before pruning]
x: [0.145986523936967 , 0.174476635651758];
res: [0.15546853050196 , 0.183592743008892]
[after pruning]
x: [0.145986523936967 , 0.174476635651758];
res: [0.15546853050196 , 0.175671900620786]

[before pruning]
x: [0.145986523936967 , 0.174476635651758];
res: [0.15546853050196 , 0.175671900620786]
[after pruning]
x: [0.145986523936967 , 0.174476635651758];
res: [0.15546853050196 , 0.175671900620786]

[before pruning]
x: [0.145986523936967 , 0.174476635651758];
res: [0.15546853050196 , 0.175671900620786]
[after pruning]
x: [0.145986523936967 , 0.166439288149138];
res: [0.15546853050196 , 0.175671900620786]

[before pruning]
x: [0.145986523936967 , 0.166439288149138];
res: [0.15546853050196 , 0.175671900620786]
[after pruning]
x: [0.145986523936967 , 0.166439288149138];
res: [0.15546853050196 , 0.167472639995228]

[before pruning]
x: [0.145986523936967 , 0.166439288149138];
res: [0.15546853050196 , 0.167472639995228]
[after pruning]
x: [0.145986523936967 , 0.158130836319191];
res: [0.15546853050196 , 0.167472639995228]

[before pruning]
x: [0.145986523936967 , 0.158130836319191];
res: [0.15546853050196 , 0.167472639995228]
[after pruning]
x: [0.145986523936967 , 0.158130836319191];
res: [0.15546853050196 , 0.167472639995228]

[before pruning]
x: [0.145986523936967 , 0.158130836319191];
res: [0.15546853050196 , 0.167472639995228]
[after pruning]
x: [0.145986523936967 , 0.158130836319191];
res: [0.15546853050196 , 0.159013476904218]

[before pruning]
x: [0.145986523936967 , 0.158130836319191];
res: [0.15546853050196 , 0.159013476904218]
[after pruning]
x: [0.145986523936967 , 0.149570535778441];
res: [0.15546853050196 , 0.159013476904218]

[before pruning]
x: [0.145986523936967 , 0.149570535778441];
res: [0.15546853050196 , 0.159013476904218]
[conflict detected]

[before pruning]
x: [0.145986523936967 , 0.227723136146858];
res: [0.191218616901187 , 0.235760028700917]
[after pruning]
x: [0.145986523936967 , 0.227723136146858];
res: [0.191218616901187 , 0.230466111294382]

[before pruning]
x: [0.145986523936967 , 0.227723136146858];
res: [0.191218616901187 , 0.230466111294382]
[after pruning]
x: [0.145986523936967 , 0.222292314156614];
res: [0.191218616901187 , 0.230466111294382]

[before pruning]
x: [0.145986523936967 , 0.222292314156614];
res: [0.191218616901187 , 0.230466111294382]
[after pruning]
x: [0.145986523936967 , 0.222292314156614];
res: [0.191218616901187 , 0.230466111294382]

[before pruning]
x: [0.145986523936967 , 0.222292314156614];
res: [0.191218616901187 , 0.230466111294382]
[after pruning]
x: [0.145986523936967 , 0.222292314156614];
res: [0.191218616901187 , 0.224834536927897]

[before pruning]
x: [0.145986523936967 , 0.222292314156614];
res: [0.191218616901187 , 0.224834536927897]
[after pruning]
x: [0.145986523936967 , 0.222292314156614];
res: [0.191218616901187 , 0.224834536927897]

[before pruning]
x: [0.145986523936967 , 0.222292314156614];
res: [0.191218616901187 , 0.224834536927897]
[after pruning]
x: [0.145986523936967 , 0.216522407758067];
res: [0.191218616901187 , 0.224834536927897]

[before pruning]
x: [0.145986523936967 , 0.216522407758067];
res: [0.191218616901187 , 0.224834536927897]
[after pruning]
x: [0.145986523936967 , 0.216522407758067];
res: [0.191218616901187 , 0.224834536927897]

[before pruning]
x: [0.145986523936967 , 0.216522407758067];pp
res: [0.191218616901187 , 0.224834536927897]
[after pruning]
x: [0.189670441183 , 0.216522407758067];
res: [0.191218616901187 , 0.224834536927897]

[before pruning]
x: [0.189670441183 , 0.216522407758067];
res: [0.191218616901187 , 0.224834536927897]
[after pruning]
x: [0.189670441183 , 0.216522407758067];
res: [0.191218616901187 , 0.218863023630274]

[before pruning]
x: [0.189670441183 , 0.216522407758067];
res: [0.191218616901187 , 0.218863023630274]
[after pruning]
x: [0.189670441183 , 0.21041219709813];
res: [0.198535256572455 , 0.218863023630274]

[before pruning]
x: [0.189670441183 , 0.21041219709813];
res: [0.198535256572455 , 0.218863023630274]
[after pruning]
x: [0.189670441183 , 0.21041219709813];
res: [0.198535256572455 , 0.218863023630274]

[before pruning]
x: [0.189670441183 , 0.21041219709813];
res: [0.198535256572455 , 0.218863023630274]
[after pruning]
x: [0.189670441183 , 0.21041219709813];
res: [0.198535256572455 , 0.212551952279247]

[before pruning]
x: [0.189670441183 , 0.21041219709813];
res: [0.198535256572455 , 0.212551952279247]
[after pruning]
x: [0.189670441183 , 0.20396319186542];
res: [0.198535256572455 , 0.212551952279247]

[before pruning]
x: [0.189670441183 , 0.20396319186542];
res: [0.198535256572455 , 0.212551952279247]
[after pruning]
x: [0.189670441183 , 0.20396319186542];
res: [0.198535256572455 , 0.205904493765148]

[before pruning]
x: [0.189670441183 , 0.20396319186542];
res: [0.198535256572455 , 0.205904493765148]
[after pruning]
x: [0.189670441183 , 0.20396319186542];
res: [0.198535256572455 , 0.205904493765148]

[before pruning]
x: [0.189670441183 , 0.20396319186542];
res: [0.198535256572455 , 0.205904493765148]
[after pruning]
x: [0.189670441183 , 0.197179731808181];
res: [0.198535256572455 , 0.205904493765148]

[before pruning]
x: [0.189670441183 , 0.197179731808181];
res: [0.198535256572455 , 0.205904493765148]
[after pruning]
x: [0.189670441183 , 0.197179731808181];
res: [0.198535256572455 , 0.198926666709451]

[before pruning]
x: [0.189670441183 , 0.197179731808181];
res: [0.198535256572455 , 0.198926666709451]
[after pruning]
x: [0.189670441183 , 0.190069014145096];
res: [0.198535256572455 , 0.198926666709451]

[before pruning]
x: [0.189670441183 , 0.190069014145096];
res: [0.198535256572455 , 0.198926666709451]
[after pruning]
x: [0.189670441183 , 0.190069014145096];
res: [0.198535256572455 , 0.198926666709451]

[before pruning]
x: [0.189670441183 , 0.190069014145096];
res: [0.198535256572455 , 0.198926666709451]

[before pruning]
x: [0.00999978436854053 , 0.246164905434643];
res: [0.01 , 0.253686278200172]
[after pruning]
x: [0.00999978436854053 , 0.246164905434643];
res: [0.01 , 0.249674359014133]

[before pruning]
x: [0.00999978436854053 , 0.246164905434643];
res: [0.01 , 0.249674359014133]
[after pruning]
x: [0.00999978436854053 , 0.242030419864151];
res: [0.0199996177134884 , 0.249674359014133]

[before pruning]
x: [0.00999978436854053 , 0.242030419864151];
res: [0.0199996177134884 , 0.249674359014133]
[after pruning]
x: [0.0300041193648224 , 0.242030419864151];
res: [0.0199996177134884 , 0.229674359014133]

[before pruning]
x: [0.0300041193648224 , 0.242030419864151];
res: [0.0199996177134884 , 0.229674359014133]
[after pruning]
x: [0.0300041193648224 , 0.226960247302013];
res: [0.0199996177134884 , 0.229674359014133]

[before pruning]
x: [0.0300041193648224 , 0.226960247302013];
res: [0.0199996177134884 , 0.229674359014133]
[after pruning]
x: [0.0300041193648224 , 0.226960247302013];
res: [0.0300099342065431 , 0.229674359014133]

[before pruning]
x: [0.0300041193648224 , 0.226960247302013];
res: [0.0300099342065431 , 0.229674359014133]
[after pruning]
x: [0.0300041193648224 , 0.221480663446357];
res: [0.0399996177134884 , 0.229674359014133]

[before pruning]
x: [0.0300041193648224 , 0.221480663446357];
res: [0.0399996177134884 , 0.229674359014133]
[after pruning]
x: [0.0500204740405061 , 0.221480663446357];
res: [0.0399996177134884 , 0.209674359014133]

[before pruning]
x: [0.0500204740405061 , 0.221480663446357];
res: [0.0399996177134884 , 0.209674359014133]
[after pruning]
x: [0.0500204740405061 , 0.221480663446357];
res: [0.05004748199691 , 0.209674359014133]

[before pruning]
x: [0.0500204740405061 , 0.221480663446357];
res: [0.05004748199691 , 0.209674359014133]
[after pruning]
x: [0.0500204740405061 , 0.20102557611781];
res: [0.0599996177134884 , 0.209674359014133]

[before pruning]
x: [0.0500204740405061 , 0.20102557611781];
res: [0.0599996177134884 , 0.209674359014133]
[after pruning]
x: [0.0700569098614857 , 0.20102557611781];
res: [0.0599996177134884 , 0.189674359014133]

[before pruning]
x: [0.0700569098614857 , 0.20102557611781];
res: [0.0599996177134884 , 0.189674359014133]
[after pruning]
x: [0.0700569098614857 , 0.20102557611781];
res: [0.0701313798043171 , 0.189674359014133]

[before pruning]
x: [0.0700569098614857 , 0.20102557611781];
res: [0.0701313798043171 , 0.189674359014133]
[after pruning]
x: [0.0700569098614857 , 0.180655413143108];
res: [0.0799996177134884 , 0.189674359014133]

[before pruning]
x: [0.0700569098614857 , 0.180655413143108];
res: [0.0799996177134884 , 0.189674359014133]
[after pruning]
x: [0.0901215611703603 , 0.180655413143108];
res: [0.0799996177134884 , 0.169674359014133]

[before pruning]
x: [0.0901215611703603 , 0.180655413143108];
res: [0.0799996177134884 , 0.169674359014133]
[after pruning]
x: [0.0901215611703603 , 0.180655413143108];
res: [0.0902808630487284 , 0.169674359014133]

[before pruning]
x: [0.0901215611703603 , 0.180655413143108];
res: [0.0902808630487284 , 0.169674359014133]
[after pruning]
x: [0.0901215611703603 , 0.16036077079887];
res: [0.0999996177134884 , 0.169674359014133]

[before pruning]
x: [0.0901215611703603 , 0.16036077079887];
res: [0.0999996177134884 , 0.169674359014133]
[after pruning]
x: [0.110222665367207 , 0.16036077079887];
res: [0.0999996177134884 , 0.149674359014133]

[before pruning]
x: [0.110222665367207 , 0.16036077079887];
res: [0.0999996177134884 , 0.149674359014133]
[after pruning]
x: [0.110222665367207 , 0.16036077079887];
res: [0.110515877140696 , 0.149674359014133]

[before pruning]
x: [0.110222665367207 , 0.16036077079887];
res: [0.110515877140696 , 0.149674359014133]
[after pruning]
x: [0.110222665367207 , 0.14013254239125];
res: [0.119999617713488 , 0.149674359014133]

[before pruning]
x: [0.110222665367207 , 0.14013254239125];
res: [0.119999617713488 , 0.149674359014133]
[after pruning]
x: [0.130368594144793 , 0.14013254239125];
res: [0.119999617713488 , 0.129674359014133]

[before pruning]
x: [0.130368594144793 , 0.14013254239125];
res: [0.119999617713488 , 0.129674359014133]
[conflict detected]
#+END_CODE

* Suggestions

#+ATTR_REVEAL: :frag fade-in
 - Do *NOT* directly call the standard C library for floating point computations
 - Use more *trustworthy* floating-point libraries such as GMP (still need to verify)
 - Balance between performance and reliability

* Conclusion

#+ATTR_REVEAL: :frag fade-in
  - Floating point computations can produce *wildly wrong* results
  - *Big threat* to safety (not avoidable by better engineering)
  - We have methdology for *ensuring correctness*
  - Our tools are *ready to transfer*, right now
  - Need close collaboration from GM to work out frontend for
    full-scale embedded code
